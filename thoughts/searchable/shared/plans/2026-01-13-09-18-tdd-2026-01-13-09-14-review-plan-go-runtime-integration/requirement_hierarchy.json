{
  "requirements": [
    {
      "id": "REQ_000",
      "description": "The review_plan command must be incorporated into the Go runtime following the established Cobra CLI command pattern used by existing commands (plan, resume, mcp-setup)",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_000.1",
          "description": "Create command definition in go/internal/cli/review_plan.go as a Cobra Command following the established pattern used by planCmd, mcpSetupCmd, and resumeCmd",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "File go/internal/cli/review_plan.go exists and compiles without errors",
            "Package declaration is 'package cli' matching other CLI files",
            "Import statements include 'github.com/spf13/cobra' and 'github.com/silmari/context-engine/go/internal/planning'",
            "Variable reviewPlanCmd is defined as *cobra.Command with Use field set to 'review-plan'",
            "Command has Short description: 'Review an implementation plan before execution'",
            "Command has Long description with usage examples matching style in plan.go",
            "Command has RunE field pointing to runReviewPlan handler function",
            "Flag variables are defined at package level following pattern in plan.go (reviewPlanPath, reviewPhase, reviewStep, reviewOutputPath, reviewAutonomyMode)",
            "init() function defines all command-specific flags using Flags().StringVarP and Flags().BoolVarP patterns",
            "Flags include: --plan-path (-p), --phase, --step, --output (-o), --autonomy-mode, --all-phases flag for full review",
            "Flag normalization function normalizeUnderscoredFlags is applied for backward compatibility",
            "Valid phase choices match PhaseType enum: research, decomposition, tdd_planning, multi_doc, beads_sync, implementation",
            "Valid step choices match 5-step review framework: contracts, interfaces, promises, data_models, apis"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create new file go/internal/cli/review_plan.go",
              "Define reviewPlanCmd variable as cobra.Command struct with Use, Aliases, Short, Long, RunE fields",
              "Define package-level flag variables: reviewPlanPath, reviewPhase, reviewStep, reviewOutputPath, reviewAutonomyMode, reviewAllPhases",
              "Implement init() function that registers flags on reviewPlanCmd.Flags()",
              "Add validation constants for valid phases (validReviewPhases) and steps (validReviewSteps)",
              "Include flag descriptions matching style in plan.go"
            ],
            "middleware": [],
            "shared": [
              "Import planning package for PhaseType and AutonomyMode enums",
              "Use FlagPlanPath, FlagOutput constants from flags.go where applicable",
              "Consider adding new flag constants to flags.go: FlagPhase, FlagStep, FlagAllPhases, FlagAutonomyMode"
            ]
          },
          "testable_properties": [],
          "function_id": "cli.reviewPlanCmd",
          "related_concepts": [
            "cobra.Command",
            "Cobra CLI pattern",
            "CLI subcommand registration",
            "review_plan prompt template"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2",
          "description": "Register review-plan command in root.go init() function using rootCmd.AddCommand() following the established registration pattern",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "root.go init() function includes 'rootCmd.AddCommand(reviewPlanCmd)' line",
            "Registration appears in logical order with other subcommands (after planCmd, mcpSetupCmd, resumeCmd)",
            "No import cycle errors after adding the command",
            "Running 'context-engine --help' displays 'review-plan' in Available Commands list",
            "Running 'context-engine review-plan --help' displays the command's help text",
            "Command is accessible via 'context-engine review-plan' invocation",
            "Build succeeds without errors after registration"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Edit go/internal/cli/root.go to add 'rootCmd.AddCommand(reviewPlanCmd)' in init() function",
              "Place registration line after existing AddCommand calls (planCmd, mcpSetupCmd, resumeCmd) at approximately line 54-55",
              "Verify no circular imports exist between root.go and review_plan.go",
              "Run 'go build ./...' to verify successful compilation"
            ],
            "middleware": [],
            "shared": [
              "reviewPlanCmd must be exported from review_plan.go (starts with lowercase as it's package-private, but referenced within same package)",
              "Ensure reviewPlanCmd is defined before init() runs (package-level var declaration)"
            ]
          },
          "testable_properties": [],
          "function_id": "cli.init.AddCommand",
          "related_concepts": [
            "Cobra command tree",
            "rootCmd.AddCommand",
            "CLI initialization",
            "command registration order"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3",
          "description": "Implement runReviewPlan handler function following the runPlan pattern with parameter validation, path normalization, config creation, and pipeline invocation",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "Function signature is 'func runReviewPlan(cmd *cobra.Command, args []string) error'",
            "Default plan path handling: if reviewPlanPath is empty, search thoughts/searchable/shared/plans/ for recent plans",
            "Path validation: if reviewPlanPath is provided, verify file exists using os.Stat",
            "Path normalization: convert relative paths to absolute using filepath.Abs",
            "Phase validation: if reviewPhase is provided, validate against validReviewPhases using validateChoice helper",
            "Step validation: if reviewStep is provided, validate against validReviewSteps using validateChoice helper",
            "Debug output: if debug flag is true, print all configuration values following pattern in runPlan",
            "Create planning.ReviewConfig struct with validated parameters",
            "Call planning.RunReview or equivalent function with config",
            "Handle results: print success message with output path if review succeeds",
            "Handle failures: print error message with failed step if review fails",
            "Return nil on success, wrapped error on failure",
            "Support --all-phases flag to iterate over all phases sequentially",
            "Support running single phase + single step for targeted reviews"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement runReviewPlan function in go/internal/cli/review_plan.go",
              "Add plan path auto-discovery logic: search for .md files in thoughts/searchable/shared/plans/",
              "Implement path validation using os.Stat similar to runPlan lines 75-78",
              "Implement path normalization using filepath.Abs similar to runPlan lines 71-74",
              "Use validateChoice helper (from plan.go pattern) for phase and step validation",
              "Add debug output block printing all review configuration (if debug flag is true)",
              "Create planning.ReviewConfig struct with fields: PlanPath, Phase, Step, OutputPath, AutonomyMode, AllPhases",
              "Call planning.NewReviewPipeline(config).Run() or equivalent",
              "Process planning.ReviewResult: check Success field, print output paths, handle errors"
            ],
            "middleware": [
              "Validate that plan file exists and is readable before proceeding",
              "Validate phase and step values against allowed choices before proceeding"
            ],
            "shared": [
              "Define ReviewConfig struct in go/internal/planning/models.go or new review.go file",
              "Define ReviewResult struct with Success, Findings, OutputPath, FailedAt, Error fields",
              "Add validReviewPhases slice matching PhaseType values: ['research', 'decomposition', 'tdd_planning', 'multi_doc', 'beads_sync', 'implementation']",
              "Add validReviewSteps slice matching 5-step framework: ['contracts', 'interfaces', 'promises', 'data_models', 'apis']"
            ]
          },
          "testable_properties": [],
          "function_id": "cli.runReviewPlan",
          "related_concepts": [
            "Cobra RunE handler",
            "error handling",
            "path validation",
            "planning.ReviewConfig",
            "planning.RunReview"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.4",
          "description": "Add command aliases for convenient invocation of the review-plan command, following the pattern used by planCmd which has alias 'p'",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "reviewPlanCmd has Aliases field defined in cobra.Command struct",
            "Primary alias 'rp' is defined for quick invocation (context-engine rp)",
            "Secondary alias 'review' is defined for clarity (context-engine review)",
            "Running 'context-engine rp --help' displays same help as 'context-engine review-plan --help'",
            "Running 'context-engine review --help' displays same help as 'context-engine review-plan --help'",
            "All aliases accept the same flags as the primary command",
            "Help text displays aliases in the format: 'Aliases: review-plan, rp, review'",
            "Tab completion works for all aliases (if shell completion is configured)"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add Aliases field to reviewPlanCmd cobra.Command struct: Aliases: []string{\"rp\", \"review\"}",
              "Verify aliases don't conflict with existing commands (plan has 'p', no conflicts with 'rp' or 'review')",
              "Update Long description to mention available aliases",
              "Test all alias invocations: 'context-engine rp', 'context-engine review', 'context-engine review-plan'"
            ],
            "middleware": [],
            "shared": [
              "Document aliases in command help text for discoverability",
              "Consider adding alias documentation to any CLI help/usage documentation"
            ]
          },
          "testable_properties": [],
          "function_id": "cli.reviewPlanCmd.Aliases",
          "related_concepts": [
            "Cobra aliases",
            "command shortcuts",
            "CLI usability",
            "backward compatibility"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_001",
      "description": "The review process must implement a 5-step discrete analysis framework covering Contracts, Interfaces, Promises, Data Models, and APIs",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_001.1",
          "description": "Implement Contract Analysis step for component boundaries, input/output contracts, error contracts, and preconditions/postconditions/invariants",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "Contract analyzer identifies all component boundaries in the plan/phase being reviewed",
            "Input contracts are validated: each function/method has clearly defined input types, constraints, and valid ranges",
            "Output contracts are validated: each function/method has clearly defined return types and guarantees",
            "Error contracts are validated: each component specifies what exceptions/errors it can throw and under what conditions",
            "Preconditions are identified and validated: conditions that must be true before a function executes",
            "Postconditions are identified and validated: conditions that must be true after a function completes",
            "Invariants are identified and validated: conditions that must always be true for data structures/objects",
            "Findings are categorized into three severity levels: well-defined (\u2705), warning (\u26a0\ufe0f), critical (\u274c)",
            "Analysis produces machine-parseable ContractAnalysisResult struct with counts by severity",
            "Contract analysis integrates with RequirementNode hierarchy via recursive tree traversal pattern",
            "Analysis respects sequential phase dependencies (Phase N analyzed after Phase N-1 completes)"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create ContractAnalysisResult struct in go/internal/planning/review.go with fields: ComponentBoundaries []BoundaryFinding, InputContracts []ContractFinding, OutputContracts []ContractFinding, ErrorContracts []ContractFinding, Preconditions []ConditionFinding, Postconditions []ConditionFinding, Invariants []InvariantFinding",
              "Create ContractFinding struct with: Location string, Description string, Severity string (well_defined|warning|critical), Recommendation string",
              "Implement analyzeContracts(phase PhaseType, requirements *RequirementHierarchy) *ContractAnalysisResult function",
              "Create Claude prompt template for contract analysis in go/internal/planning/prompts.go: PROMPT_CONTRACT_ANALYSIS",
              "Implement recursive requirementContractTraversal(node *RequirementNode, step string) []ContractFinding following GetByID pattern from models.go lines 103-114",
              "Add contract analysis step to AllReviewSteps() enum similar to AllPhases() pattern in models.go lines 598-608",
              "Implement component boundary detection by parsing Implementation.Frontend, Implementation.Backend, Implementation.Middleware, Implementation.Shared arrays",
              "Create validation rules for each contract type with configurable strictness levels"
            ],
            "middleware": [
              "Implement contract validation rules that can be configured via CLI flags (--strict-contracts, --require-error-contracts)",
              "Add caching layer for contract analysis results to avoid re-analyzing unchanged phases"
            ],
            "shared": [
              "Define ContractAnalysisResult struct in go/internal/planning/models.go",
              "Add Severity enum: SeverityWellDefined, SeverityWarning, SeverityCritical with String() method",
              "Create shared validation helper functions for checking contract completeness"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.analyzeContracts",
          "related_concepts": [
            "component_boundaries",
            "input_output_contracts",
            "error_handling",
            "design_by_contract",
            "invariants",
            "preconditions",
            "postconditions"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.2",
          "description": "Implement Interface Analysis step for public method definitions, naming convention consistency, interface evolution/extension points, and visibility modifiers",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "Interface analyzer identifies all public method definitions in each requirement's implementation components",
            "Naming convention consistency is validated: method names follow project-specific patterns (camelCase, PascalCase, snake_case as appropriate)",
            "Interface evolution points are identified: extension methods, hooks, plugin points, strategy patterns",
            "Visibility modifiers are analyzed: public/private/protected appropriateness for each method",
            "Analyzer detects potential breaking changes in interface definitions",
            "Analyzer identifies missing interface abstractions where concrete implementations are exposed",
            "Analysis integrates with the 3-tier requirement hierarchy (parent \u2192 sub_process \u2192 implementation)",
            "Findings include specific recommendations for each issue with code examples where applicable",
            "Interface analysis produces InterfaceAnalysisResult struct with severity categorization",
            "Analysis can be run incrementally (single phase) or comprehensively (all phases)",
            "Naming conventions are validated against configurable project patterns loaded from .claude/config or project settings"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create InterfaceAnalysisResult struct in go/internal/planning/review.go with fields: PublicMethods []MethodFinding, NamingIssues []NamingFinding, ExtensionPoints []ExtensionFinding, VisibilityIssues []VisibilityFinding",
              "Create MethodFinding struct with: Name string, Location string, Signature string, Severity string, Issues []string",
              "Implement analyzeInterfaces(phase PhaseType, requirements *RequirementHierarchy) *InterfaceAnalysisResult function",
              "Create Claude prompt template PROMPT_INTERFACE_ANALYSIS that instructs analysis of method signatures, naming patterns, and extension points",
              "Implement naming convention detection using regex patterns for common styles (camelCase: ^[a-z][a-zA-Z0-9]*$, PascalCase: ^[A-Z][a-zA-Z0-9]*$, snake_case: ^[a-z][a-z0-9_]*$)",
              "Create extension point detector that identifies: factory methods, strategy interfaces, plugin hooks, event handlers",
              "Implement visibility analysis using language-specific patterns (Go: exported vs unexported, TypeScript: public/private/protected)",
              "Add interface analysis as second step in review loop after contract analysis"
            ],
            "middleware": [
              "Implement configurable naming convention rules loaded from project configuration",
              "Add pattern matching service for detecting inconsistent naming across the codebase"
            ],
            "shared": [
              "Define InterfaceAnalysisResult struct in go/internal/planning/models.go",
              "Create NamingConventionConfig struct to hold project-specific naming rules",
              "Define ExtensionPointType enum: Factory, Strategy, Plugin, EventHandler, Hook",
              "Add utility functions for parsing method signatures from plan documentation"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.analyzeInterfaces",
          "related_concepts": [
            "interface_design",
            "public_api",
            "naming_conventions",
            "extensibility",
            "visibility_modifiers",
            "api_surface_area",
            "backward_compatibility"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.3",
          "description": "Implement Promise Analysis step for behavioral guarantees (idempotency, ordering), async/concurrent operations, timeout/cancellation handling, and resource cleanup (RAII patterns)",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "Promise analyzer identifies all behavioral guarantees in the plan: idempotency, ordering, determinism",
            "Idempotency analysis validates: operations that should produce same result when called multiple times are identified and verified",
            "Ordering analysis validates: operations with ordering dependencies are identified with explicit sequencing requirements",
            "Async/concurrent operations are identified with their synchronization mechanisms (mutexes, channels, semaphores)",
            "Timeout handling is validated: all async operations have explicit timeout specifications",
            "Cancellation handling is validated: all long-running operations support context cancellation patterns",
            "Resource cleanup patterns are identified: RAII, defer statements, try-finally blocks, cleanup handlers",
            "Analysis identifies potential race conditions or deadlock scenarios",
            "Analysis detects missing timeout specifications on network/IO operations",
            "Promise analysis integrates with TestableProperty types from models.go (idempotence, round_trip, invariant, oracle)",
            "Findings map to ValidPropertyTypes for automated test generation compatibility"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create PromiseAnalysisResult struct in go/internal/planning/review.go with fields: IdempotencyGuarantees []IdempotencyFinding, OrderingGuarantees []OrderingFinding, AsyncOperations []AsyncFinding, TimeoutHandling []TimeoutFinding, CancellationHandling []CancellationFinding, ResourceCleanup []CleanupFinding",
              "Create IdempotencyFinding struct with: Operation string, Guarantee bool, Rationale string, TestStrategy string",
              "Implement analyzePromises(phase PhaseType, requirements *RequirementHierarchy) *PromiseAnalysisResult function",
              "Create Claude prompt template PROMPT_PROMISE_ANALYSIS that analyzes behavioral guarantees across requirement nodes",
              "Implement idempotency detector using pattern matching for: PUT vs POST semantics, retry-safe operations, cache invalidation patterns",
              "Create async operation detector that identifies: goroutines, channels, mutexes, wait groups, context.Context usage",
              "Implement timeout analysis that checks for: context.WithTimeout, time.After, deadline specifications",
              "Create resource cleanup detector for: defer statements, Close() calls, cleanup functions, finally blocks",
              "Map findings to TestableProperty.PropertyType values for test generation integration",
              "Add promise analysis as third step in review loop"
            ],
            "middleware": [
              "Implement concurrency pattern validator that checks for common anti-patterns (unbuffered channel deadlocks, mutex lock ordering)",
              "Add timeout policy enforcer that flags operations missing timeout specifications"
            ],
            "shared": [
              "Define PromiseAnalysisResult struct in go/internal/planning/models.go",
              "Create AsyncPatternType enum: Goroutine, Channel, Mutex, WaitGroup, Context, Future",
              "Define CleanupPatternType enum: Defer, Finally, RAII, Destructor, Finalizer",
              "Add mapping function MapPromiseToTestableProperty(finding PromiseFinding) *TestableProperty"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.analyzePromises",
          "related_concepts": [
            "idempotency",
            "ordering_guarantees",
            "async_patterns",
            "concurrency",
            "timeouts",
            "cancellation",
            "resource_cleanup",
            "RAII",
            "determinism"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.4",
          "description": "Implement Data Model Analysis step for field definitions with types, optional vs required clarity, relationships (1:1, 1:N, N:M), and migration/backward compatibility",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "Data model analyzer identifies all data structures defined in requirements",
            "Field definitions are validated: each field has explicit type annotation",
            "Optional vs required clarity is validated: each field explicitly states whether it is required or optional",
            "Relationship analysis identifies all entity relationships: 1:1 (one-to-one), 1:N (one-to-many), N:M (many-to-many)",
            "Foreign key relationships are identified and validated for referential integrity",
            "Migration strategy is analyzed: backward compatibility of schema changes is assessed",
            "Analysis detects breaking changes: removed fields, type changes, constraint additions",
            "Analysis identifies missing validation rules for data fields",
            "Data model analysis integrates with ImplementationComponents.Shared array for identifying shared data structures",
            "Analysis produces DataModelAnalysisResult with field-level findings",
            "Relationship cardinality is explicitly documented with navigation direction"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create DataModelAnalysisResult struct in go/internal/planning/review.go with fields: FieldDefinitions []FieldFinding, OptionalityIssues []OptionalityFinding, Relationships []RelationshipFinding, MigrationIssues []MigrationFinding",
              "Create FieldFinding struct with: EntityName string, FieldName string, Type string, IsRequired bool, Validation []string, Severity string",
              "Create RelationshipFinding struct with: FromEntity string, ToEntity string, Cardinality string (one_to_one|one_to_many|many_to_many), NavigationDirection string, ForeignKey string",
              "Implement analyzeDataModels(phase PhaseType, requirements *RequirementHierarchy) *DataModelAnalysisResult function",
              "Create Claude prompt template PROMPT_DATA_MODEL_ANALYSIS for analyzing struct definitions and relationships",
              "Implement field type detector that parses: struct definitions, interface declarations, type aliases",
              "Create optionality analyzer that identifies: pointer types (*T), Optional<T>, nullable annotations, omitempty tags",
              "Implement relationship detector that identifies: slice/array fields, map fields, foreign key patterns",
              "Create migration compatibility checker that compares current vs proposed schema changes",
              "Add data model analysis as fourth step in review loop"
            ],
            "middleware": [
              "Implement schema diff service that compares proposed data models against existing ones",
              "Add migration risk assessor that flags potentially breaking changes"
            ],
            "shared": [
              "Define DataModelAnalysisResult struct in go/internal/planning/models.go",
              "Create Cardinality enum: OneToOne, OneToMany, ManyToMany",
              "Define MigrationRisk enum: None, Low, Medium, High, Breaking",
              "Add utility functions for parsing Go struct tags (json, bson, db tags)"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.analyzeDataModels",
          "related_concepts": [
            "data_modeling",
            "field_types",
            "optionality",
            "entity_relationships",
            "schema_migration",
            "backward_compatibility",
            "data_validation"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.5",
          "description": "Implement API Analysis step for endpoint/method definitions, request/response formats, error responses/status codes, and versioning/deprecation policies",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "API analyzer identifies all endpoint/method definitions in requirements",
            "Endpoint definitions are validated: HTTP method, path, path parameters, query parameters",
            "Request format analysis validates: content type, required fields, validation rules, example payloads",
            "Response format analysis validates: success response structure, content type, pagination patterns",
            "Error response analysis validates: error codes, error message structure, HTTP status code mapping",
            "HTTP status codes are validated against REST conventions (200 OK, 201 Created, 400 Bad Request, etc.)",
            "API versioning strategy is identified and validated: URL versioning (/v1/), header versioning, query param versioning",
            "Deprecation policies are identified: sunset headers, deprecation warnings, migration guides",
            "Analysis detects missing error handling for common failure modes (validation, auth, not found, conflict)",
            "API analysis integrates with ImplementationComponents.Backend array for identifying API endpoints",
            "Analysis produces APIAnalysisResult with endpoint-level findings compatible with OpenAPI spec generation"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create APIAnalysisResult struct in go/internal/planning/review.go with fields: Endpoints []EndpointFinding, RequestFormats []RequestFinding, ResponseFormats []ResponseFinding, ErrorResponses []ErrorResponseFinding, VersioningStrategy *VersioningFinding, DeprecationPolicies []DeprecationFinding",
              "Create EndpointFinding struct with: Method string, Path string, PathParams []string, QueryParams []string, Description string, Severity string, Issues []string",
              "Create ErrorResponseFinding struct with: StatusCode int, ErrorCode string, MessageFormat string, HasDocumentation bool",
              "Implement analyzeAPIs(phase PhaseType, requirements *RequirementHierarchy) *APIAnalysisResult function",
              "Create Claude prompt template PROMPT_API_ANALYSIS for analyzing API definitions and contracts",
              "Implement endpoint detector that parses: HTTP annotations, router definitions, handler registrations",
              "Create request/response format analyzer that identifies: JSON schemas, protobuf definitions, content types",
              "Implement HTTP status code validator against REST conventions with configurable strictness",
              "Create versioning strategy detector that identifies: URL path versioning, Accept header versioning, custom header versioning",
              "Implement deprecation policy detector that identifies: Deprecation headers, Sunset headers, warning responses",
              "Add API analysis as fifth and final step in review loop"
            ],
            "middleware": [
              "Implement OpenAPI spec compatibility checker that validates findings against OpenAPI 3.0 requirements",
              "Add API consistency enforcer that checks for uniform error formats and response structures"
            ],
            "shared": [
              "Define APIAnalysisResult struct in go/internal/planning/models.go",
              "Create HTTPMethod enum: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS",
              "Define VersioningStrategy enum: URLPath, AcceptHeader, CustomHeader, QueryParam, None",
              "Create StatusCodeCategory enum: Informational, Success, Redirection, ClientError, ServerError",
              "Add mapping function MapStatusCodeToCategory(code int) StatusCodeCategory"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.analyzeAPIs",
          "related_concepts": [
            "api_design",
            "rest_endpoints",
            "request_response",
            "http_status_codes",
            "error_handling",
            "api_versioning",
            "deprecation",
            "openapi"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_002",
      "description": "The system must handle sequential phase dependencies where each phase (Research \u2192 Decomposition \u2192 TDD_Planning \u2192 Multi_Doc \u2192 Beads_Sync \u2192 Implementation) depends on the previous phase completing successfully",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_002.1",
          "description": "Implement phase iteration using AllPhases() enumeration returning all PhaseType values in sequential order from Research to Implementation",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "AllPhases() returns a slice of all 6 PhaseType values in exact order: PhaseResearch, PhaseDecomposition, PhaseTDDPlanning, PhaseMultiDoc, PhaseBeadsSync, PhaseImplementation",
            "PhaseIterator exposes a ForEach(callback func(PhaseType) error) method that iterates through phases in order and stops on first error",
            "PhaseIterator exposes a GetPhaseAtIndex(index int) (PhaseType, error) method that returns the phase at a given index or error if out of bounds",
            "PhaseIterator exposes a GetPhaseCount() int method that returns 6 (total number of phases)",
            "Phase iteration maintains consistent ordering across multiple calls (idempotent)",
            "PhaseIterator can be reset to start iteration from the beginning",
            "Unit tests verify iteration order matches the defined sequence exactly",
            "Integration test confirms all 6 phases are visited exactly once during full pipeline execution"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create PhaseIterator struct in go/internal/planning/phase_iterator.go",
              "Implement ForEach() method that accepts a callback and iterates through AllPhases() slice",
              "Implement GetPhaseAtIndex() method with bounds checking returning appropriate error for invalid index",
              "Implement GetPhaseCount() method returning len(AllPhases())",
              "Implement Reset() method to reset internal iteration state",
              "Add CurrentPhase() method to track iteration position for debugging/logging"
            ],
            "middleware": [],
            "shared": [
              "Utilize existing AllPhases() function from models.go (lines 598-608)",
              "Utilize existing PhaseType enumeration from models.go (lines 509-519)",
              "Create PhaseIterationError type for iteration-specific error handling"
            ]
          },
          "testable_properties": [],
          "function_id": "PhaseIterator.IterateAllPhases",
          "related_concepts": [
            "PhaseType enumeration",
            "AllPhases() function",
            "sequential iteration",
            "phase ordering",
            "pipeline execution flow"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_002.2",
          "description": "Implement dependency checking that verifies all prerequisite phases have completed successfully before allowing a phase to be processed",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "AreDependenciesMet(phase PhaseType) returns true only if ALL phases preceding the target phase have StatusComplete",
            "AreDependenciesMet(PhaseResearch) always returns true since Research has no dependencies",
            "AreDependenciesMet(PhaseDecomposition) returns true only if PhaseResearch has StatusComplete",
            "AreDependenciesMet returns false if any preceding phase has StatusPending, StatusInProgress, or StatusFailed",
            "Function provides detailed error information indicating which specific phase(s) are blocking",
            "GetBlockingPhases(phase PhaseType) returns a slice of PhaseType values that are not yet complete",
            "Method handles nil or uninitialized PhaseResults map gracefully (treats as all pending)",
            "Unit tests verify correct dependency check for each of the 6 phases",
            "Unit tests verify false is returned when any upstream phase has failed status",
            "Edge case: calling AreDependenciesMet on a phase with StatusComplete or StatusFailed still checks dependencies correctly"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add AreDependenciesMet(phase PhaseType) bool method to PipelineState struct in models.go",
              "Add AreDependenciesMetWithReason(phase PhaseType) (bool, string) method that returns detailed failure reason",
              "Add GetBlockingPhases(phase PhaseType) []PhaseType method to identify all incomplete upstream phases",
              "Implement logic using Previous() method and IsPhaseComplete() to check all preceding phases",
              "Add helper method to iterate from PhaseResearch up to (but not including) target phase"
            ],
            "middleware": [],
            "shared": [
              "Utilize existing IsPhaseComplete() method from PipelineState (models.go line 921-924)",
              "Utilize existing Previous() method from PhaseType (models.go lines 569-575)",
              "Utilize existing PhaseStatus enumeration and StatusComplete constant",
              "Create DependencyCheckResult struct with Met bool, BlockingPhases []PhaseType, Reason string fields"
            ]
          },
          "testable_properties": [],
          "function_id": "PipelineState.AreDependenciesMet",
          "related_concepts": [
            "phase dependencies",
            "sequential constraints",
            "PipelineState",
            "PhaseStatus",
            "dependency validation",
            "blocking detection"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_002.3",
          "description": "Support Next() and Previous() navigation methods for bidirectional phase traversal with proper boundary handling",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "Next() returns the subsequent phase for all phases except PhaseImplementation",
            "Next() on PhaseImplementation returns error 'implementation is the final phase'",
            "Previous() returns the preceding phase for all phases except PhaseResearch",
            "Previous() on PhaseResearch returns error 'research is the first phase'",
            "Navigation chain is consistent: phase.Next().Previous() equals original phase (where applicable)",
            "IsFirstPhase() method returns true only for PhaseResearch",
            "IsLastPhase() method returns true only for PhaseImplementation",
            "HasNext() method returns false only for PhaseImplementation",
            "HasPrevious() method returns false only for PhaseResearch",
            "GetDistanceFromStart() returns 0 for PhaseResearch, 5 for PhaseImplementation",
            "GetDistanceToEnd() returns 5 for PhaseResearch, 0 for PhaseImplementation",
            "Unit tests verify all phase transitions for both Next() and Previous()",
            "Unit tests verify error messages match expected text exactly"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Verify existing Next() implementation in models.go (lines 561-567) handles boundary correctly",
              "Verify existing Previous() implementation in models.go (lines 569-575) handles boundary correctly",
              "Add IsFirstPhase() bool method returning pt == PhaseResearch",
              "Add IsLastPhase() bool method returning pt == PhaseImplementation",
              "Add HasNext() bool method returning pt != PhaseImplementation",
              "Add HasPrevious() bool method returning pt != PhaseResearch",
              "Add GetDistanceFromStart() int method returning int(pt)",
              "Add GetDistanceToEnd() int method returning int(PhaseImplementation) - int(pt)"
            ],
            "middleware": [],
            "shared": [
              "Extend existing PhaseType methods in models.go",
              "Create NavigationError type with Code (boundary violation) and Phase fields",
              "Define constant error messages for boundary conditions"
            ]
          },
          "testable_properties": [],
          "function_id": "PhaseType.NavigationMethods",
          "related_concepts": [
            "PhaseType methods",
            "phase navigation",
            "boundary conditions",
            "linked list pattern",
            "phase sequence"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_002.4",
          "description": "Implement PhaseStatus state machine with valid transitions enforcing proper lifecycle: pending\u2192in_progress\u2192complete/failed with retry support from failed state",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "CanTransitionTo() returns true for pending\u2192in_progress transition",
            "CanTransitionTo() returns true for in_progress\u2192complete transition",
            "CanTransitionTo() returns true for in_progress\u2192failed transition",
            "CanTransitionTo() returns true for failed\u2192in_progress transition (retry)",
            "CanTransitionTo() returns false for complete\u2192any transition (terminal state)",
            "CanTransitionTo() returns false for pending\u2192complete (must go through in_progress)",
            "CanTransitionTo() returns false for pending\u2192failed (must go through in_progress)",
            "TransitionTo() method performs transition and returns error if invalid",
            "IsTerminal() returns true for StatusComplete and StatusFailed",
            "IsPending() returns true only for StatusPending",
            "IsActive() returns true only for StatusInProgress",
            "GetValidTransitions() returns slice of valid next states for current state",
            "State transition events are logged for debugging/audit",
            "Unit tests cover all valid transitions returning true",
            "Unit tests cover all invalid transitions returning false",
            "Integration test verifies phase cannot be marked complete without going through in_progress"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Verify existing CanTransitionTo() implementation in models.go (lines 657-671)",
              "Add TransitionTo(next PhaseStatus) error method that validates and performs transition",
              "Add IsTerminal() bool method (already exists at line 652-655, verify correctness)",
              "Add IsPending() bool method returning ps == StatusPending",
              "Add IsActive() bool method returning ps == StatusInProgress",
              "Add GetValidTransitions() []PhaseStatus method returning valid next states",
              "Create StateTransitionEvent struct with From, To, Timestamp, Phase fields for logging"
            ],
            "middleware": [
              "Add transition logging middleware that records all state changes",
              "Add validation middleware that prevents invalid state transitions in API layer"
            ],
            "shared": [
              "Utilize existing PhaseStatus enumeration from models.go (lines 610-618)",
              "Utilize existing CanTransitionTo() method from models.go (lines 657-671)",
              "Create TransitionError type with From, To, Reason fields",
              "Define transition matrix as constant map[PhaseStatus][]PhaseStatus for valid transitions"
            ]
          },
          "testable_properties": [],
          "function_id": "PhaseStatus.StateMachine",
          "related_concepts": [
            "state machine",
            "PhaseStatus",
            "state transitions",
            "workflow enforcement",
            "retry mechanism",
            "terminal states"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_003",
      "description": "The system must handle hierarchical requirement dependencies using a 3-tier structure (parent \u2192 sub_process \u2192 implementation) with recursive tree traversal",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_003.1",
          "description": "Implement RequirementNode structure with ID, Description, Type, ParentID, and Children fields to support 3-tier hierarchical requirements",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "RequirementNode struct contains ID field as string type for unique identification",
            "RequirementNode struct contains Description field as string type for requirement text",
            "RequirementNode struct contains Type field as string type with valid values: 'parent', 'sub_process', 'implementation'",
            "RequirementNode struct contains ParentID field as string type (omitempty for root nodes)",
            "RequirementNode struct contains Children field as slice of *RequirementNode pointers for recursive nesting",
            "All fields have appropriate JSON struct tags with omitempty where applicable",
            "ValidRequirementTypes map validates Type field values",
            "Validate() method returns error for invalid Type values",
            "Validate() method returns error for empty Description",
            "Struct supports JSON marshaling/unmarshaling for persistence",
            "Unit tests verify all field assignments and validation scenarios"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define RequirementNode struct in go/internal/planning/models.go",
              "Implement ValidRequirementTypes map with 'parent', 'sub_process', 'implementation' keys",
              "Implement Validate() method on RequirementNode receiver",
              "Add ImplementationComponents embedded struct for frontend/backend/middleware/shared arrays",
              "Add TestableProperties slice field for property-based test mapping",
              "Add AcceptanceCriteria string slice field for requirement criteria",
              "Add FunctionID field for linking to specific function implementations",
              "Add RelatedConcepts string slice for concept cross-referencing",
              "Add Category field with ValidCategories map validation"
            ],
            "middleware": [],
            "shared": [
              "Define RequirementNode JSON schema in shared documentation",
              "Create type constants or enum for requirement types",
              "Define error types for validation failures (ErrInvalidRequirementType, ErrEmptyDescription)"
            ]
          },
          "testable_properties": [],
          "function_id": "RequirementNode.struct",
          "related_concepts": [
            "hierarchical_data_structure",
            "tree_data_model",
            "recursive_struct",
            "json_serialization",
            "parent_child_relationship"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.2",
          "description": "Support hierarchical ID format (e.g., REQ_000, REQ_000.1, REQ_000.1.1) with automatic ID generation for parent-child relationships",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "Top-level requirement IDs follow pattern REQ_XXX where XXX is zero-padded 3-digit number",
            "Sub-process IDs follow pattern PARENT_ID.N where N is sequential child number starting at 1",
            "Implementation IDs follow pattern PARENT_ID.N where N is sequential under sub_process",
            "NextChildID() method generates next sequential child ID from parent",
            "NextTopLevelID() method generates next top-level REQ_XXX ID",
            "AddChild() method automatically sets ParentID on child node",
            "ID format supports arbitrary nesting depth (e.g., REQ_000.1.1.1)",
            "Unit tests verify ID generation for 3-tier hierarchy: parent \u2192 sub_process \u2192 implementation",
            "ID parsing can extract parent ID from child ID (e.g., REQ_000 from REQ_000.1)",
            "Duplicate ID detection prevents adding child with existing ID"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement NextChildID() method on RequirementNode that returns fmt.Sprintf('%s.%d', r.ID, len(r.Children)+1)",
              "Implement AddChild(*RequirementNode) method that sets child.ParentID = r.ID before appending",
              "Implement NextTopLevelID() on RequirementHierarchy that returns fmt.Sprintf('REQ_%03d', len(h.Requirements))",
              "Implement AddChild(parentID string, child *RequirementNode) on RequirementHierarchy with parent lookup",
              "Add ParseParentID(id string) helper function to extract parent ID from hierarchical ID",
              "Add GetDepth() method to calculate nesting level from ID (count dots + 1)",
              "Implement ID uniqueness validation in hierarchy AddChild method"
            ],
            "middleware": [],
            "shared": [
              "Document hierarchical ID format specification in shared docs",
              "Create ID format regex pattern for validation: ^REQ_\\d{3}(\\.\\d+)*$",
              "Define constants for ID prefix (REQ_) and separator (.)"
            ]
          },
          "testable_properties": [],
          "function_id": "RequirementNode.hierarchicalID",
          "related_concepts": [
            "hierarchical_id_pattern",
            "dot_notation",
            "sequential_numbering",
            "id_generation",
            "parent_child_linking"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.3",
          "description": "Implement recursive GetByID() method for tree traversal to find any requirement node by ID at any depth in the hierarchy",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "GetByID(id string) returns *RequirementNode pointer when ID matches current node",
            "GetByID recursively searches all children when current node ID doesn't match",
            "GetByID returns nil when ID is not found in entire subtree",
            "GetByID handles empty Children slice without panic",
            "GetByID works correctly for root, intermediate, and leaf nodes",
            "RequirementHierarchy.GetByID searches across all top-level requirements",
            "Time complexity is O(n) where n is total nodes in tree",
            "Unit tests verify lookup at all 3 tiers: parent, sub_process, implementation",
            "Unit tests verify nil return for non-existent IDs",
            "Unit tests verify correct node returned when multiple nodes exist with similar ID prefixes"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement GetByID(id string) *RequirementNode on RequirementNode struct with recursive depth-first search",
              "Check if r.ID == id, return r if match",
              "Iterate over r.Children slice, recursively call child.GetByID(id)",
              "Return found child if not nil, otherwise continue iteration",
              "Return nil after exhausting all children",
              "Implement GetByID(id string) *RequirementNode on RequirementHierarchy that iterates Requirements slice",
              "Add GetAll() method to return flattened slice of all nodes via recursive traversal",
              "Add GetByType(reqType string) to filter nodes by Type field",
              "Add GetLeafNodes() to return only implementation-tier nodes"
            ],
            "middleware": [],
            "shared": [
              "Define TreeTraversal interface with GetByID method for polymorphism",
              "Create iterator pattern for tree traversal if needed for large hierarchies"
            ]
          },
          "testable_properties": [],
          "function_id": "RequirementNode.GetByID",
          "related_concepts": [
            "recursive_tree_traversal",
            "depth_first_search",
            "node_lookup",
            "pointer_return",
            "nil_handling"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.4",
          "description": "Implement reviewRequirementTree() function for recursive requirement review that applies review steps to entire requirement hierarchy",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "reviewRequirementTree(node *RequirementNode, step string) returns []ReviewFinding slice",
            "Function applies reviewNode() to current node and collects findings",
            "Function recursively calls reviewRequirementTree for each child node",
            "Findings from all descendants are aggregated into single slice",
            "Review handles all 5 steps: contracts, interfaces, promises, data_models, apis",
            "Empty children slice results in only current node being reviewed",
            "ReviewFinding struct captures severity (well_defined, warning, critical)",
            "ReviewFinding includes node ID, step name, and finding description",
            "Function supports early termination on critical findings if configured",
            "Unit tests verify aggregation of findings across 3-tier hierarchy",
            "Unit tests verify each review step is applied to each node",
            "Performance is O(n*s) where n is nodes and s is review steps"
          ],
          "implementation": {
            "frontend": [
              "Display review findings in hierarchical tree view matching requirement structure",
              "Color-code findings by severity: green (well_defined), yellow (warning), red (critical)",
              "Allow expanding/collapsing requirement nodes to show/hide child findings",
              "Provide filter controls to show only specific severity levels"
            ],
            "backend": [
              "Create ReviewFinding struct with NodeID, Step, Severity, Description, Recommendation fields",
              "Create ReviewSeverity enum/constants: SeverityWellDefined, SeverityWarning, SeverityCritical",
              "Implement reviewNode(node *RequirementNode, step string) ReviewFinding function",
              "Implement reviewRequirementTree(node *RequirementNode, step string) []ReviewFinding with recursive aggregation",
              "Create reviewAllSteps(node *RequirementNode) []ReviewFinding that iterates all 5 review steps",
              "Add ReviewSteps constant slice: []string{'contracts', 'interfaces', 'promises', 'data_models', 'apis'}",
              "Implement ReviewResult struct aggregating findings by phase and step",
              "Add countBySeverity() helper to summarize findings",
              "Integrate with Claude prompt templates for AI-assisted review analysis",
              "Support configurable review depth limit for large hierarchies"
            ],
            "middleware": [
              "Add review step validation middleware to ensure valid step names",
              "Implement rate limiting for Claude API calls during review"
            ],
            "shared": [
              "Define ReviewFinding JSON schema for API responses and persistence",
              "Define ReviewSteps constant array shared between frontend/backend",
              "Create ReviewSeverity enum shared for consistent severity handling"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.reviewRequirementTree",
          "related_concepts": [
            "recursive_review",
            "tree_aggregation",
            "review_findings",
            "depth_first_accumulation",
            "review_step_application"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_004",
      "description": "The system must implement a three-level severity classification for review findings: Well-Defined (\u2705), Warning (\u26a0\ufe0f), and Critical (\u274c)",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_004.1",
          "description": "Mark review items as Well-Defined (\u2705) when the analyzed component meets all requirements with no action needed",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "Function accepts a ReviewFinding struct and marks it with SeverityWellDefined (\u2705) status",
            "Well-Defined status is only assigned when ALL of the following are true: component has explicit input/output contracts, interfaces are fully defined, behavioral guarantees are documented, and API contracts are complete",
            "Well-Defined items are stored in the WellDefined []string slice of ReviewStepResult",
            "Function returns the updated ReviewFinding with Severity field set to 'well_defined'",
            "Well-Defined items are excluded from recommendation generation (no action needed)",
            "System tracks count of Well-Defined items per review step (contracts, interfaces, promises, data_models, apis)",
            "Well-Defined classification is applied recursively through nested RequirementNode children",
            "JSON serialization outputs \u2705 symbol for well_defined severity in report generation"
          ],
          "implementation": {
            "frontend": [
              "Display \u2705 icon next to Well-Defined items in review report UI",
              "Green color coding for Well-Defined status in severity legend",
              "Collapsible section for Well-Defined items (collapsed by default to focus on issues)",
              "Count badge showing number of Well-Defined items per review category"
            ],
            "backend": [
              "Add SeverityWellDefined constant to ReviewSeverity enum type in models.go",
              "Implement MarkWellDefined(finding *ReviewFinding) function in review.go",
              "Add validation logic to verify all criteria are met before assigning Well-Defined status",
              "Implement criteria checkers: hasExplicitContracts(), hasDefinedInterfaces(), hasDocumentedGuarantees(), hasCompleteAPI()",
              "Store Well-Defined findings in ReviewStepResult.WellDefined slice"
            ],
            "middleware": [
              "Severity classification validation in review pipeline before checkpoint save",
              "Ensure Well-Defined items pass through without triggering blocking logic"
            ],
            "shared": [
              "Add SeverityWellDefined to ReviewSeverity type: const SeverityWellDefined ReviewSeverity = 0",
              "Add Severity field to ReviewFinding struct",
              "Define ValidSeverities map[string]bool with 'well_defined' entry",
              "Add Symbol() method to ReviewSeverity returning '\u2705' for WellDefined"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewSeverity.MarkWellDefined",
          "related_concepts": [
            "severity_classification",
            "review_finding",
            "contract_analysis",
            "interface_analysis",
            "status_indicator"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.2",
          "description": "Mark review items as Warning (\u26a0\ufe0f) when issues should be addressed but are not blocking implementation",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "Function accepts a ReviewFinding struct and marks it with SeverityWarning (\u26a0\ufe0f) status",
            "Warning status is assigned when: component has partial specification, naming inconsistencies exist, extension points are unclear, or backward compatibility is not explicitly addressed",
            "Warning items are stored in the Warnings []string slice of ReviewStepResult",
            "Function accepts an optional reason string explaining why the warning was raised",
            "Warning findings do NOT block phase progression in the pipeline (StatusInProgress \u2192 StatusComplete allowed)",
            "Warnings are flagged for recommendation generation but do not halt execution",
            "System tracks count of Warning items per review step and per phase",
            "Warning items are persisted to checkpoint for review resumption",
            "JSON serialization outputs \u26a0\ufe0f symbol for warning severity in report generation"
          ],
          "implementation": {
            "frontend": [
              "Display \u26a0\ufe0f icon next to Warning items in review report UI",
              "Yellow/amber color coding for Warning status in severity legend",
              "Expandable section for Warning items showing details and recommendations",
              "Sort Warning items by review category (contracts, interfaces, promises, data_models, apis)",
              "Optional 'acknowledge warning' checkbox to track user review"
            ],
            "backend": [
              "Add SeverityWarning constant to ReviewSeverity enum type in models.go",
              "Implement MarkWarning(finding *ReviewFinding, reason string) function in review.go",
              "Add warning criteria detection: detectPartialSpec(), detectNamingInconsistency(), detectUnclearExtensions(), detectMissingBackwardCompat()",
              "Store Warning findings in ReviewStepResult.Warnings slice",
              "Implement non-blocking checkpoint logic for phases with warnings",
              "Add WarningCount() method to ReviewStepResult"
            ],
            "middleware": [
              "Allow phase status transition when only warnings present (no critical findings)",
              "Log warning findings without failing pipeline execution",
              "Pass warning findings to recommendation generator service"
            ],
            "shared": [
              "Add SeverityWarning to ReviewSeverity type: const SeverityWarning ReviewSeverity = 1",
              "Add Reason field to ReviewFinding struct for warning context",
              "Add IsBlocking() method to ReviewSeverity returning false for Warning",
              "Add Symbol() method to ReviewSeverity returning '\u26a0\ufe0f' for Warning"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewSeverity.MarkWarning",
          "related_concepts": [
            "severity_classification",
            "non_blocking_issues",
            "review_finding",
            "recommendation_generation",
            "technical_debt"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.3",
          "description": "Mark review items as Critical (\u274c) when they must be resolved before implementation can proceed",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "Function accepts a ReviewFinding struct and marks it with SeverityCritical (\u274c) status",
            "Critical status is assigned when: contracts are undefined or contradictory, interfaces have missing method definitions, promises conflict (e.g., idempotency violated), data models have ambiguous relationships, or APIs have undefined error handling",
            "Critical items are stored in the Critical []string slice of ReviewStepResult",
            "Critical findings BLOCK phase progression (StatusInProgress cannot transition to StatusComplete)",
            "Function accepts a required resolution_needed string describing what must be fixed",
            "System enforces that phases with Critical findings must retry after fixes (StatusFailed \u2192 StatusInProgress allowed)",
            "Critical findings trigger mandatory recommendation generation",
            "Review cannot complete (phase marked complete) while Critical items exist",
            "Critical items are logged with high visibility in checkpoint files",
            "JSON serialization outputs \u274c symbol for critical severity in report generation"
          ],
          "implementation": {
            "frontend": [
              "Display \u274c icon next to Critical items in review report UI",
              "Red color coding for Critical status in severity legend",
              "Critical items section always expanded and pinned to top of report",
              "Required 'resolution plan' text field for each Critical item",
              "Block 'proceed to implementation' button when Critical items exist",
              "Visual indicator showing number of Critical items blocking progress"
            ],
            "backend": [
              "Add SeverityCritical constant to ReviewSeverity enum type in models.go",
              "Implement MarkCritical(finding *ReviewFinding, resolutionNeeded string) function in review.go",
              "Add critical criteria detection: detectUndefinedContracts(), detectMissingMethods(), detectConflictingPromises(), detectAmbiguousRelationships(), detectUndefinedErrorHandling()",
              "Store Critical findings in ReviewStepResult.Critical slice",
              "Implement blocking checkpoint logic: prevent StatusComplete when Critical.length > 0",
              "Add CriticalCount() method to ReviewStepResult",
              "Modify CanTransitionTo() in PhaseStatus to check for Critical findings"
            ],
            "middleware": [
              "Block phase status transition when critical findings present",
              "Return error with critical findings list when attempting to complete phase",
              "Force recommendation generation for all critical findings before checkpoint save"
            ],
            "shared": [
              "Add SeverityCritical to ReviewSeverity type: const SeverityCritical ReviewSeverity = 2",
              "Add ResolutionNeeded field to ReviewFinding struct (required for Critical)",
              "Add IsBlocking() method to ReviewSeverity returning true for Critical",
              "Add Symbol() method to ReviewSeverity returning '\u274c' for Critical",
              "Add HasCritical() bool method to ReviewStepResult"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewSeverity.MarkCritical",
          "related_concepts": [
            "severity_classification",
            "blocking_issues",
            "review_finding",
            "implementation_blocker",
            "phase_dependency"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.4",
          "description": "Generate actionable recommendations for Warning and Critical findings to guide resolution",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "Function accepts a ReviewStepResult containing Warning and Critical findings and generates recommendations",
            "Recommendations are stored in the Recommendations []string slice of ReviewStepResult",
            "Each Warning finding receives at least one recommendation describing how to address it",
            "Each Critical finding receives at least one mandatory recommendation with specific resolution steps",
            "Recommendations include: specific file/line references when available, suggested code changes, and related documentation references",
            "Well-Defined (\u2705) findings are skipped - no recommendations generated",
            "Recommendations are prioritized: Critical recommendations listed first, then Warning recommendations",
            "Function can invoke Claude for AI-assisted recommendation generation when enabled",
            "Recommendations are persisted to checkpoint and included in review report output",
            "Empty recommendation list is valid only when no Warning or Critical findings exist"
          ],
          "implementation": {
            "frontend": [
              "Display recommendations section in review report below findings",
              "Collapsible recommendation cards with severity indicator",
              "Copy-to-clipboard button for each recommendation",
              "Link recommendations to their source finding",
              "Priority sorting: Critical recommendations displayed first with red indicator",
              "Checkbox to mark recommendations as 'addressed' for tracking"
            ],
            "backend": [
              "Implement GenerateRecommendations(result *ReviewStepResult) []string function in review.go",
              "Add recommendation templates per review step type (contracts, interfaces, promises, data_models, apis)",
              "Implement generateWarningRecommendation(finding *ReviewFinding) string",
              "Implement generateCriticalRecommendation(finding *ReviewFinding) string",
              "Add Claude prompt templates for AI-assisted recommendations in prompts/",
              "Store recommendations in ReviewStepResult.Recommendations slice",
              "Implement prioritizeRecommendations() to sort Critical before Warning"
            ],
            "middleware": [
              "Validate that all Critical findings have at least one recommendation before checkpoint",
              "Enforce recommendation generation as part of review pipeline completion",
              "Log recommendation generation metrics (count, AI vs template, time)"
            ],
            "shared": [
              "Add Recommendations []string field to ReviewStepResult struct",
              "Define RecommendationType enum (ActionRequired, Suggestion, Documentation)",
              "Add Recommendation struct with fields: Severity, FindingID, Description, SuggestedFix, FileReference",
              "Add recommendation templates as constants in review_templates.go"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewService.GenerateRecommendations",
          "related_concepts": [
            "recommendation_generation",
            "severity_classification",
            "review_finding",
            "action_items",
            "resolution_guidance"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_005",
      "description": "The system must support three autonomy modes for review execution: Checkpoint, Batch, and Fully Autonomous",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_005.1",
          "description": "Implement Checkpoint Mode to review each phase individually, execute all 5 review steps (contracts, interfaces, promises, data models, APIs) for each phase, persist state after completion, and pause for user approval before proceeding to the next phase",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "Each of the 6 phases (Research, Decomposition, TDDPlanning, MultiDoc, BeadsSync, Implementation) must be reviewed individually before pausing",
            "All 5 review steps (contracts, interfaces, promises, data_models, apis) must execute sequentially for each phase before checkpoint",
            "Phase dependencies must be validated using areDependenciesMet(phase) before starting review of any phase",
            "Checkpoint must be saved with phase identifier, all ReviewStepResult data, and timestamp after each phase completes",
            "System must block execution and wait for explicit user approval signal before proceeding to next phase",
            "User must be able to view review findings (WellDefined \u2705, Warnings \u26a0\ufe0f, Critical \u274c) at each checkpoint pause",
            "Critical findings (\u274c) in a phase must be flagged and require explicit acknowledgment to proceed",
            "Resume capability must restore exact checkpoint state including phase index and accumulated results",
            "Checkpoint JSON file must follow existing checkpoint.go structure with phase-specific review data in Data map"
          ],
          "implementation": {
            "frontend": [
              "CLI output displaying phase review summary with severity counts (\u2705/\u26a0\ufe0f/\u274c)",
              "Interactive prompt for approval (continue/abort/view-details) at each checkpoint",
              "Color-coded terminal output distinguishing Well-Defined, Warning, and Critical findings",
              "Progress indicator showing current phase (N of 6) and overall review progress"
            ],
            "backend": [
              "executeCheckpointMode(planPath string, startPhase PhaseType) (*ReviewResult, error) function in review.go",
              "Phase iteration loop using AllPhases() with checkpoint save after each phase",
              "waitForApproval() function that blocks until user input received",
              "Integration with existing checkpoint.go saveCheckpoint() pattern",
              "Accumulator for ReviewStepResult structs across all phases"
            ],
            "middleware": [
              "Phase dependency validation check before starting each phase review",
              "Checkpoint file locking to prevent concurrent modification",
              "Signal handler for graceful interruption that saves partial checkpoint"
            ],
            "shared": [
              "AutonomyMode enum constant AutonomyCheckpoint = 0",
              "ReviewCheckpoint struct extending base Checkpoint with ReviewStepResult[]",
              "PhaseReviewStatus struct tracking completion state per phase"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.executeCheckpointMode",
          "related_concepts": [
            "AutonomyCheckpoint",
            "PhaseType",
            "ReviewStepResult",
            "saveCheckpoint",
            "PhaseStatus",
            "phase dependency validation"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_005.2",
          "description": "Implement Batch Mode to group related phases together, execute all reviews within each group without pausing, and pause only at defined group boundaries for consolidated approval",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "Phases must be grouped into logical batches: Group 1 (Research, Decomposition), Group 2 (TDDPlanning, MultiDoc), Group 3 (BeadsSync, Implementation)",
            "All phases within a batch must complete their full review (all 5 steps each) before checkpoint pause",
            "Batch boundary checkpoint must aggregate all ReviewStepResult data from all phases in the batch",
            "User must receive consolidated report showing findings across all phases in the completed batch",
            "Critical findings in any phase within a batch must be surfaced in the consolidated batch report",
            "System must not pause between phases within the same batch",
            "Resume from batch checkpoint must restart from the beginning of the current batch, not mid-batch",
            "Batch grouping configuration must be customizable via --batch-groups flag or config file"
          ],
          "implementation": {
            "frontend": [
              "Consolidated batch summary output showing all phases reviewed in current batch",
              "Table format displaying findings by phase within batch for easy comparison",
              "Batch progress indicator (Batch N of M, containing phases X, Y, Z)",
              "Interactive batch approval prompt with option to review individual phase details"
            ],
            "backend": [
              "executeBatchMode(planPath string, batchConfig []PhaseGroup) (*ReviewResult, error) function",
              "PhaseGroup struct defining batch membership: type PhaseGroup struct { Name string; Phases []PhaseType }",
              "Default batch configuration: getDefaultBatchGroups() returning 3 predefined groups",
              "Batch iteration loop with inner phase loop, checkpoint only at batch boundaries",
              "aggregateBatchResults(phaseResults map[PhaseType][]ReviewStepResult) *BatchReviewSummary function"
            ],
            "middleware": [
              "Batch configuration validation ensuring all phases are assigned to exactly one batch",
              "Batch-level dependency check: all phases in previous batches must be complete before starting new batch",
              "Transaction-like behavior: if any phase in batch fails, entire batch marked incomplete"
            ],
            "shared": [
              "AutonomyMode enum constant AutonomyBatch = 2",
              "PhaseGroup struct with Name, Phases, and Order fields",
              "BatchCheckpoint struct containing batch index and aggregated phase results",
              "DEFAULT_BATCH_GROUPS constant defining standard groupings"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.executeBatchMode",
          "related_concepts": [
            "AutonomyBatch",
            "PhaseGroup",
            "batch boundaries",
            "consolidated review report",
            "group-level checkpoint"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_005.3",
          "description": "Implement Fully Autonomous Mode to execute the complete review pipeline across all phases and all review steps without any user intervention, producing a final comprehensive report upon completion",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "All 6 phases must be reviewed sequentially without any pause for user input",
            "All 5 review steps must execute for each phase (30 total review operations)",
            "Phase dependencies must still be validated but failures should be logged and continued, not blocked",
            "Final comprehensive report must include all findings from all phases and steps",
            "Total execution time must be tracked and reported",
            "Any critical findings (\u274c) must be prominently highlighted in final report but not block execution",
            "Exit code must reflect overall review health: 0 for all pass, 1 for warnings only, 2 for critical issues",
            "Report must be written to specified --output path in REVIEW.md format matching existing examples",
            "Execution must be suitable for CI/CD pipeline integration with machine-readable output option"
          ],
          "implementation": {
            "frontend": [
              "Progress output showing phase/step completion in real-time (optional --quiet flag to suppress)",
              "Final summary banner with total counts: phases reviewed, findings by severity",
              "Machine-readable JSON output option (--format=json) for CI/CD integration",
              "REVIEW.md formatted report matching thoughts/searchable/plans/*/REVIEW.md pattern"
            ],
            "backend": [
              "executeFullyAutonomousMode(planPath string) (*ReviewResult, error) function",
              "Non-blocking phase iteration: continue to next phase even if current has issues",
              "Parallel review step execution option within each phase for performance",
              "generateComprehensiveReport(results map[PhaseType][]ReviewStepResult) *ReviewReport function",
              "writeReportToFile(report *ReviewReport, outputPath string, format OutputFormat) error function"
            ],
            "middleware": [
              "Timeout handling per phase to prevent hanging: REVIEW_PHASE_TIMEOUT constant",
              "Error aggregation: collect all errors without failing fast",
              "Logging all operations for audit trail even in autonomous mode"
            ],
            "shared": [
              "AutonomyMode enum constant AutonomyFullyAutonomous = 1",
              "ReviewReport struct with Phases map, Summary, TotalDuration, ExitCode fields",
              "OutputFormat enum: FormatMarkdown, FormatJSON, FormatText",
              "REVIEW_PHASE_TIMEOUT constant (default 5 minutes per phase)"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.executeFullyAutonomousMode",
          "related_concepts": [
            "AutonomyFullyAutonomous",
            "unattended execution",
            "comprehensive report",
            "final aggregation",
            "non-blocking review"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_005.4",
          "description": "Implement the saveCheckpoint() function specifically for review operations to persist review state after phase completion in checkpoint mode, enabling resume capability with full context restoration",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "Checkpoint must be saved as JSON file to .context-engine/checkpoints/review-{plan-name}-{timestamp}.json",
            "Checkpoint must include: current phase index, autonomy mode, all completed phase results, pending phases list",
            "Each ReviewStepResult must be fully serialized including WellDefined, Warnings, Critical arrays",
            "Checkpoint must include original plan path and plan hash to detect if plan changed since checkpoint",
            "Atomic write pattern must be used: write to temp file, then rename to prevent corruption",
            "Checkpoint file must be human-readable for debugging (pretty-printed JSON with indentation)",
            "loadCheckpoint() must validate plan hash matches before allowing resume",
            "Checkpoint must store timestamp of last save and cumulative review duration",
            "Old checkpoints must be rotated: keep last 5, delete older ones automatically"
          ],
          "implementation": {
            "frontend": [
              "CLI message confirming checkpoint saved with file path",
              "Resume command hint displayed after checkpoint save: 'Resume with: context-engine review --resume {checkpoint-path}'",
              "Warning displayed if resuming with mismatched plan hash"
            ],
            "backend": [
              "saveReviewCheckpoint(state *ReviewState, checkpointDir string) error function",
              "loadReviewCheckpoint(checkpointPath string) (*ReviewState, error) function",
              "validateCheckpointPlan(checkpoint *ReviewCheckpoint, currentPlanPath string) error function",
              "computePlanHash(planPath string) string function using SHA-256",
              "rotateOldCheckpoints(checkpointDir string, keepCount int) error function"
            ],
            "middleware": [
              "File system permission check before checkpoint write",
              "Checkpoint directory creation if not exists: os.MkdirAll pattern",
              "File locking during write to prevent concurrent access"
            ],
            "shared": [
              "ReviewCheckpoint struct extending Checkpoint: PlanPath, PlanHash, CurrentPhase, AutonomyMode, CompletedResults, PendingPhases, Duration, Timestamp",
              "CHECKPOINT_DIR constant: '.context-engine/checkpoints'",
              "CHECKPOINT_KEEP_COUNT constant: 5",
              "ReviewState struct containing full in-memory review execution state"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.saveReviewCheckpoint",
          "related_concepts": [
            "checkpoint persistence",
            "JSON serialization",
            "resume state",
            "atomic write",
            "checkpoint.go pattern"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_006",
      "description": "The review_plan command must implement the proposed loop architecture with outer phase iteration, middle review step iteration, and inner recursive requirement traversal",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_006.1",
          "description": "Implement outer loop iterating over phases sequentially using AllPhases(), checking dependency satisfaction before processing each phase and respecting autonomy mode settings for checkpointing",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Loop iterates through all 6 phases in correct order: Research \u2192 Decomposition \u2192 TDD_Planning \u2192 Multi_Doc \u2192 Beads_Sync \u2192 Implementation",
            "areDependenciesMet(phase) is called before processing each phase and skips phases with unmet dependencies",
            "Phase iteration uses AllPhases() method from models.go for consistent ordering",
            "Loop tracks current phase index for checkpoint resume capability",
            "When autonomyMode == AutonomyCheckpoint, saveCheckpoint() is called after each phase completes",
            "When autonomyMode == AutonomyBatch, checkpoints occur only at group boundaries",
            "When autonomyMode == AutonomyFullyAutonomous, no checkpoints interrupt execution",
            "Phase transition follows valid state machine: pending \u2192 in_progress \u2192 complete/failed",
            "Failed phases can be retried by transitioning from failed \u2192 in_progress",
            "Loop terminates gracefully if any phase has critical blocking issues (\u274c findings)",
            "Phase results are accumulated and passed to next phase for dependency context"
          ],
          "implementation": {
            "frontend": [
              "Phase progress indicator showing current phase in sequence (1 of 6)",
              "Visual representation of phase dependency chain with completion status",
              "Pause/resume controls when in checkpoint autonomy mode",
              "Phase skip button for phases with unmet dependencies"
            ],
            "backend": [
              "ReviewOrchestrator.iteratePhases(planPath string, autonomyMode AutonomyMode) (*ReviewResults, error)",
              "areDependenciesMet(phase PhaseType, completedPhases []PhaseType) bool helper function",
              "Phase iteration state machine with StatusPending \u2192 StatusInProgress \u2192 StatusComplete/StatusFailed transitions",
              "saveCheckpoint(phase PhaseType, results *ReviewResults) error for state persistence",
              "loadCheckpoint(planPath string) (*ReviewCheckpoint, error) for resume capability"
            ],
            "middleware": [
              "Phase validation to ensure plan file exists and is valid before iteration begins",
              "Timeout handling per phase with configurable duration",
              "Error recovery to mark phase as failed and continue or halt based on criticality"
            ],
            "shared": [
              "PhaseIterationState struct { CurrentPhase PhaseType, CompletedPhases []PhaseType, SkippedPhases []PhaseType }",
              "PhaseResult struct { Phase PhaseType, Status PhaseStatus, StepResults map[string]*ReviewStepResult }",
              "AllPhases() []PhaseType constant slice for iteration"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.iteratePhases",
          "related_concepts": [
            "PhaseType enumeration",
            "AllPhases() method",
            "AutonomyMode",
            "Phase dependency checking",
            "Sequential iteration",
            "Checkpoint persistence"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.2",
          "description": "Implement middle loop iterating over 5 review steps (contracts, interfaces, promises, data_models, apis) for each phase, collecting findings with severity levels",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Loop iterates through exactly 5 review steps in order: contracts \u2192 interfaces \u2192 promises \u2192 data_models \u2192 apis",
            "Each step executes runReviewStep(phase, step) and captures ReviewStepResult",
            "Contract analysis checks: component boundaries, input/output contracts, error contracts, preconditions/postconditions/invariants",
            "Interface analysis checks: public method definitions, naming conventions, extension points, visibility modifiers",
            "Promise analysis checks: behavioral guarantees, async/concurrent operations, timeout/cancellation handling, resource cleanup",
            "Data model analysis checks: field definitions with types, optional vs required, relationships (1:1, 1:N, N:M), migration compatibility",
            "API analysis checks: endpoint definitions, request/response formats, error responses, versioning policies",
            "Results categorized by severity: WellDefined (\u2705), Warnings (\u26a0\ufe0f), Critical (\u274c)",
            "Step results stored in results[phase][step] map structure",
            "Claude invocation per step with specific prompt template for that analysis type",
            "Step execution time tracked for performance metrics",
            "Failed step does not block subsequent steps within same phase (collect all findings)"
          ],
          "implementation": {
            "frontend": [
              "Step progress indicator showing current step within phase (e.g., 'contracts 1/5')",
              "Severity badges with color coding: green (\u2705), yellow (\u26a0\ufe0f), red (\u274c)",
              "Expandable/collapsible sections for each review step's findings",
              "Summary counts per severity level for quick overview"
            ],
            "backend": [
              "executeReviewSteps(phase PhaseType, phaseContent *PhaseContent) (map[string]*ReviewStepResult, error)",
              "runReviewStep(phase PhaseType, step string, content *PhaseContent) (*ReviewStepResult, error)",
              "reviewContracts(content *PhaseContent) (*ReviewStepResult, error)",
              "reviewInterfaces(content *PhaseContent) (*ReviewStepResult, error)",
              "reviewPromises(content *PhaseContent) (*ReviewStepResult, error)",
              "reviewDataModels(content *PhaseContent) (*ReviewStepResult, error)",
              "reviewAPIs(content *PhaseContent) (*ReviewStepResult, error)",
              "RunClaudeSync(prompt string, timeout time.Duration, verbose bool, projectPath string) integration for each step"
            ],
            "middleware": [
              "Step execution timeout with configurable limits per step type",
              "Claude API rate limiting to prevent quota exhaustion",
              "Response validation to ensure Claude output matches expected format"
            ],
            "shared": [
              "ReviewStep type enum: StepContracts, StepInterfaces, StepPromises, StepDataModels, StepAPIs",
              "AllReviewSteps() []ReviewStep function returning ordered slice",
              "ReviewStepResult struct { Success bool, Step string, Phase PhaseType, WellDefined []string, Warnings []string, Critical []string, Recommendations []string }",
              "StepPromptTemplates map[ReviewStep]string for Claude prompt generation"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.executeReviewSteps",
          "related_concepts": [
            "5-step review framework",
            "Severity levels (\u2705 \u26a0\ufe0f \u274c)",
            "ReviewStepResult",
            "Contract analysis",
            "Interface analysis",
            "Promise analysis",
            "Data model analysis",
            "API analysis"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.3",
          "description": "Implement inner recursive loop for requirement tree traversal using reviewRequirements(node, step) pattern, handling 3-tier hierarchy (parent \u2192 sub_process \u2192 implementation)",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Function signature: reviewRequirements(node *RequirementNode, step ReviewStep) []ReviewFinding",
            "Base case: reviewNode(node, step) returns findings for current node",
            "Recursive case: iterates over node.Children and recursively calls reviewRequirements",
            "Findings from all recursive calls are aggregated into single slice",
            "Handles 3-tier hierarchy: parent (REQ_000) \u2192 sub_process (REQ_000.1) \u2192 implementation (REQ_000.1.1)",
            "Node type (parent/sub_process/implementation) influences which review criteria apply",
            "AcceptanceCriteria field on each node is validated against review step requirements",
            "TestableProperties field validated for completeness and specificity",
            "Implementation.Components validated when present on implementation-level nodes",
            "Circular dependency detection to prevent infinite loops in malformed trees",
            "Maximum recursion depth limit (configurable, default 10) to prevent stack overflow",
            "Empty Children slice terminates recursion at leaf nodes",
            "Findings include node.ID for traceability back to specific requirement"
          ],
          "implementation": {
            "frontend": [
              "Tree visualization showing requirement hierarchy with expand/collapse",
              "Findings displayed inline with their source requirement node",
              "Filter controls to show findings by node type (parent/sub_process/implementation)",
              "Breadcrumb navigation showing requirement path (REQ_000 > REQ_000.1 > REQ_000.1.1)"
            ],
            "backend": [
              "reviewRequirements(node *RequirementNode, step ReviewStep, depth int) ([]ReviewFinding, error)",
              "reviewNode(node *RequirementNode, step ReviewStep) []ReviewFinding",
              "validateAcceptanceCriteria(node *RequirementNode, step ReviewStep) []ReviewFinding",
              "validateTestableProperties(node *RequirementNode) []ReviewFinding",
              "validateImplementationComponents(node *RequirementNode) []ReviewFinding",
              "detectCircularDependency(node *RequirementNode, visited map[string]bool) error"
            ],
            "middleware": [
              "Recursion depth guard with configurable MAX_RECURSION_DEPTH constant",
              "Visited node tracking to detect and report circular references",
              "Node validation to ensure required fields (ID, Type) are present"
            ],
            "shared": [
              "ReviewFinding struct { NodeID string, Severity SeverityLevel, Category string, Message string, Recommendation string }",
              "SeverityLevel enum: SeverityWellDefined, SeverityWarning, SeverityCritical",
              "NodeType enum validation: NodeTypeParent, NodeTypeSubProcess, NodeTypeImplementation",
              "RequirementNode struct reuse from existing models.go"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.reviewRequirements",
          "related_concepts": [
            "RequirementNode struct",
            "Recursive tree traversal",
            "GetByID method",
            "3-tier hierarchy",
            "ParentID/Children relationships",
            "Depth-first traversal",
            "Finding aggregation"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.4",
          "description": "Collect results in map structure indexed by phase and step, supporting aggregation, filtering, and report generation",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Results stored in map[PhaseType]map[ReviewStep]*ReviewStepResult structure",
            "Thread-safe map operations if parallel step execution is enabled",
            "Aggregation functions: countBySeverity(results) returns map[SeverityLevel]int",
            "Filter functions: filterBySeverity(results, severity) returns filtered results",
            "Filter functions: filterByPhase(results, phase) returns phase-specific results",
            "Filter functions: filterByStep(results, step) returns step-specific results",
            "Overall summary calculation: hasBlockingIssues(results) returns true if any Critical findings",
            "Results serializable to JSON for checkpoint persistence",
            "Results exportable to REVIEW.md markdown format matching existing report structure",
            "Results include metadata: timestamp, plan path, git commit, reviewer",
            "Empty results map initialized before iteration begins",
            "Results accessible during iteration for cross-phase dependency analysis"
          ],
          "implementation": {
            "frontend": [
              "Results dashboard showing summary counts by phase and severity",
              "Tabular view with rows for phases and columns for review steps",
              "Export buttons for JSON and Markdown formats",
              "Real-time updates as review progresses"
            ],
            "backend": [
              "ReviewResults struct { Results map[PhaseType]map[ReviewStep]*ReviewStepResult, Metadata *ReviewMetadata }",
              "initResultsMap() map[PhaseType]map[ReviewStep]*ReviewStepResult",
              "storeResult(results *ReviewResults, phase PhaseType, step ReviewStep, result *ReviewStepResult)",
              "aggregateResults(results *ReviewResults) *ReviewSummary",
              "filterResults(results *ReviewResults, filter *ResultFilter) *ReviewResults",
              "exportToJSON(results *ReviewResults) ([]byte, error)",
              "exportToMarkdown(results *ReviewResults) (string, error)",
              "generateREVIEWmd(results *ReviewResults, outputPath string) error"
            ],
            "middleware": [
              "Mutex or sync.RWMutex for thread-safe map access if parallel execution enabled",
              "Result validation before storage to ensure required fields present"
            ],
            "shared": [
              "ReviewResults struct with nested maps and metadata",
              "ReviewMetadata struct { Timestamp time.Time, PlanPath string, GitCommit string, Reviewer string }",
              "ReviewSummary struct { TotalFindings int, WellDefinedCount int, WarningCount int, CriticalCount int, PhaseCount int }",
              "ResultFilter struct { Phase *PhaseType, Step *ReviewStep, Severity *SeverityLevel }"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.collectResults",
          "related_concepts": [
            "StepResult struct",
            "Map data structure",
            "Result aggregation",
            "Severity counting",
            "REVIEW.md format",
            "JSON serialization"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.5",
          "description": "Implement loop termination with iteration limit and closure check pattern, handling blocking dependencies and critical findings",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Maximum iteration limit configurable (default from existing IMPL_TIMEOUT pattern)",
            "Iteration counter tracked: result.Iterations = i + 1 for each loop cycle",
            "Closure check: allClosed, closedIssues := checkAllIssuesClosed(projectPath, beadsIssueIDs)",
            "Early termination if hasBlockingIssues(results) returns true and stopOnCritical flag set",
            "Continue execution with warnings logged if critical findings exist but stopOnCritical is false",
            "Blocking dependency detection: for each issue check if depends_on_id is in open_ids set",
            "Blocked count tracked: blocked++ when dependency found in open issues",
            "Success flag set only when: all steps complete AND no critical findings AND tests pass (if applicable)",
            "Retry mechanism: failed phases can retry up to maxRetries before marking final failure",
            "Timeout per overall review configurable, triggers graceful termination with partial results",
            "Final result includes: iterations completed, phases reviewed, steps executed, findings summary",
            "Termination reason logged: 'max_iterations', 'all_complete', 'critical_blocking', 'timeout', 'user_cancelled'"
          ],
          "implementation": {
            "frontend": [
              "Progress bar showing iteration count and max iterations",
              "Blocking issues indicator with list of blocked phases",
              "Stop/Cancel button for user-initiated termination",
              "Termination reason display when review ends"
            ],
            "backend": [
              "terminateWithChecks(results *ReviewResults, config *TerminationConfig) (*TerminationResult, error)",
              "checkAllIssuesClosed(projectPath string, issueIDs []string) (bool, []string)",
              "detectBlockingDependencies(issues []Issue) (int, []BlockedIssue)",
              "shouldTerminate(iteration int, config *TerminationConfig, results *ReviewResults) (bool, TerminationReason)",
              "handleRetry(phase PhaseType, attempt int, maxRetries int) bool",
              "gracefulShutdown(results *ReviewResults, reason TerminationReason) *TerminationResult"
            ],
            "middleware": [
              "Context with timeout for overall review execution",
              "Cancellation signal handling for user-initiated stops",
              "Panic recovery to ensure partial results are saved on unexpected errors"
            ],
            "shared": [
              "TerminationConfig struct { MaxIterations int, MaxRetries int, Timeout time.Duration, StopOnCritical bool }",
              "TerminationResult struct { Success bool, Iterations int, Reason TerminationReason, PartialResults *ReviewResults }",
              "TerminationReason enum: ReasonMaxIterations, ReasonAllComplete, ReasonCriticalBlocking, ReasonTimeout, ReasonUserCancelled",
              "BlockedIssue struct { IssueID string, DependsOnID string, DependsOnStatus string }"
            ]
          },
          "testable_properties": [],
          "function_id": "ReviewOrchestrator.terminateWithChecks",
          "related_concepts": [
            "Loop termination",
            "maxIterations limit",
            "Closure check",
            "Blocking detection",
            "Critical findings",
            "Early exit conditions",
            "Retry mechanism"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    }
  ],
  "metadata": {
    "source": "agent_sdk_decomposition",
    "research_length": 21314,
    "decomposition_stats": {
      "requirements_found": 7,
      "subprocesses_expanded": 30,
      "total_nodes": 37,
      "extraction_time_ms": 27037,
      "expansion_time_ms": 464202
    }
  }
}