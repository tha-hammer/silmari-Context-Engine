{
  "requirements": [
    {
      "id": "REQ_000",
      "description": "The system must implement a complete 6-phase autonomous TDD pipeline ported from Python to Go",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_000.1",
          "description": "Implement the autonomous loop for the implementation phase, mimicking the Python logic. This involves repeatedly invoking Claude with the current prompt, sleeping for a defined interval, and checking if all beads issues are closed before proceeding to the next iteration.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The loop executes a maximum of 100 iterations.",
            "Each iteration invokes Claude with the current prompt.",
            "A 10-second sleep is implemented between Claude invocations.",
            "The code checks if all beads issues are closed before proceeding to the next iteration.",
            "If all beads issues are closed, the code executes tests (pytest or make test).",
            "If tests pass, the loop breaks, and the phase is marked as complete.",
            "If tests fail, the loop continues to fix the issue.",
            "The iteration count is recorded and returned as part of the phase result."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API invocation",
              "Test execution (pytest or make test)",
              "Loop control logic"
            ],
            "middleware": [],
            "shared": [
              "Prompt template",
              "Test execution command",
              "Iteration counter"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementationLoop",
          "related_concepts": [
            "Autonomous Loop",
            "Claude API",
            "Beads Integration",
            "Test Execution"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.1.1",
          "description": "Invoke Claude with a file as input, streaming the output to the console.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The function takes a file path as input.",
            "The function constructs a Claude prompt using the file content.",
            "The function invokes the Claude API with the prompt.",
            "The function streams the Claude output to the console.",
            "The function handles potential API errors."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API invocation",
              "File reading"
            ],
            "middleware": [],
            "shared": [
              "Claude API key",
              "Prompt template"
            ]
          },
          "testable_properties": [],
          "function_id": "RunClaudeWithFile",
          "related_concepts": [
            "Claude API",
            "Streaming Output",
            "File I/O"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2",
          "description": "Build prompt with TDD plan + beads issue IDs and execute Claude for 1 iteration.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "Prompt is constructed correctly with the TDD plan and beads issue IDs.",
            "Claude is invoked with the prompt.",
            "Claude's output is streamed and captured.",
            "The iteration count is incremented."
          ],
          "implementation": {
            "frontend": [
              "None - Entirely backend process"
            ],
            "backend": [
              "Call to Claude API",
              "Prompt construction logic",
              "Streaming output capture",
              "Iteration counter management"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Claude API Key",
              "Prompt Template"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_1",
          "related_concepts": [
            "TDD Plan",
            "Beads Issue IDs",
            "Claude API",
            "Streaming Output"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2.1",
          "description": "Repeat the loop (max 100 iterations) to continue Claude execution.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The loop executes up to IMPL_MAX_ITERATIONS times.",
            "Claude is invoked with the prompt in each iteration.",
            "Claude's output is streamed and captured in each iteration.",
            "The iteration count is incremented in each iteration."
          ],
          "implementation": {
            "frontend": [
              "None - Entirely backend process"
            ],
            "backend": [
              "Loop control logic",
              "Claude API call",
              "Streaming output capture",
              "Iteration counter management"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Claude API Key",
              "Prompt Template"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_2",
          "related_concepts": [
            "IMPL_LOOP_1",
            "Claude API",
            "Streaming Output",
            "Iteration Limit"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2.2",
          "description": "Check if all beads issues are closed based on Claude's output.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The code parses Claude's output to identify closed beads issues.",
            "The code verifies that all beads issues are closed.",
            "The code returns true if all issues are closed, false otherwise."
          ],
          "implementation": {
            "frontend": [
              "None - Entirely backend process"
            ],
            "backend": [
              "Claude Output Parsing Logic",
              "Status Check Logic"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Beads Issue ID Mapping"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_CHECK_BEADS",
          "related_concepts": [
            "Beads Issue IDs",
            "Claude Output Parsing",
            "Status Check"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2.3",
          "description": "If all beads issues are closed, run tests (pytest or make test).",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The code executes the specified test suite (pytest or make test).",
            "The test suite runs successfully.",
            "The test results are captured."
          ],
          "implementation": {
            "frontend": [
              "None - Entirely backend process"
            ],
            "backend": [
              "Test Execution Command",
              "Test Result Capture"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Test Suite Configuration"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_TEST_RUN",
          "related_concepts": [
            "pytest",
            "make test",
            "Test Execution"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2.4",
          "description": "If tests fail, continue the loop to fix.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "If tests fail, the loop continues to the next iteration.",
            "The loop counter is incremented."
          ],
          "implementation": {
            "frontend": [
              "None - Entirely backend process"
            ],
            "backend": [
              "Loop Control Logic"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "None"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_BREAK_LOOP",
          "related_concepts": [
            "Test Failure",
            "Loop Continuation"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.2.5",
          "description": "Return PhaseResult with iteration count.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "A PhaseResult object is created with the iteration count.",
            "The PhaseResult object is returned."
          ],
          "implementation": {
            "frontend": [
              "None - Entirely backend process"
            ],
            "backend": [
              "PhaseResult Object Creation"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "PhaseResult Schema"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_RETURN_RESULT",
          "related_concepts": [
            "PhaseResult",
            "Iteration Count"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3",
          "description": "Build prompt with TDD plan + beads issue IDs and execute Claude for 1 iteration.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "Claude receives the constructed prompt.",
            "Claude generates a response (streaming output).",
            "The response is captured and stored.",
            "The iteration count is incremented."
          ],
          "implementation": {
            "frontend": [
              "UI element to display the prompt.",
              "UI element to display the Claude response."
            ],
            "backend": [
              "Function to construct the Claude prompt.",
              "Function to call the Claude API (streaming).",
              "Function to handle the Claude response (streaming).",
              "Function to increment the iteration count."
            ],
            "middleware": [],
            "shared": [
              "Prompt template",
              "Claude API key",
              "Iteration counter"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_1",
          "related_concepts": [
            "TDD Planning",
            "Beads Integration",
            "Claude API",
            "Streaming Output"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3.1",
          "description": "Repeat the loop for a maximum of 100 iterations.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The loop executes for a maximum of 100 iterations.",
            "The iteration count does not exceed 100.",
            "The loop continues until all beads issues are closed or the iteration limit is reached."
          ],
          "implementation": {
            "frontend": [
              "UI element to display the iteration count."
            ],
            "backend": [
              "Function to control the loop execution.",
              "Function to check if all beads issues are closed.",
              "Function to sleep for 10 seconds."
            ],
            "middleware": [],
            "shared": [
              "Iteration counter",
              "Beads Issue Status"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_2",
          "related_concepts": [
            "IMPL_LOOP_1",
            "Iteration Limit",
            "Loop Control"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3.2",
          "description": "Check if all beads issues are closed based on the Claude response.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The function receives the Claude response.",
            "The function parses the response to determine if all beads issues are closed.",
            "The function returns true if all issues are closed, false otherwise."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Function to parse the Claude response.",
              "Function to check the status of each beads issue."
            ],
            "middleware": [],
            "shared": [
              "Beads Issue Status"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_CHECK_CLOSED",
          "related_concepts": [
            "Beads Integration",
            "Claude Response",
            "Issue Status"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3.3",
          "description": "If all beads issues are closed, run tests (pytest or make test).",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The function receives the Claude response.",
            "The function executes the tests.",
            "The function captures the test results.",
            "The function returns true if tests pass, false otherwise."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Function to execute tests (pytest or make test).",
              "Function to capture test results."
            ],
            "middleware": [],
            "shared": [
              "Test Suite",
              "Test Results"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_TEST_RUN",
          "related_concepts": [
            "Testing",
            "pytest",
            "make test",
            "TestableProperty"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3.4",
          "description": "If tests fail, continue the loop to fix the issues.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The function receives the test results.",
            "The function continues the loop to fix the issues.",
            "The loop continues until all beads issues are closed or the iteration limit is reached."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Function to continue the loop."
            ],
            "middleware": [],
            "shared": [
              "Test Results"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_BREAK_LOOP",
          "related_concepts": [
            "Testing",
            "Loop Control",
            "Debugging"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.3.5",
          "description": "Return PhaseResult with iteration count.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The function receives the iteration count.",
            "The function creates a PhaseResult object.",
            "The function returns the PhaseResult object."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Function to create a PhaseResult object.",
              "Function to return the PhaseResult object."
            ],
            "middleware": [],
            "shared": [
              "PhaseResult"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_RETURN_RESULT",
          "related_concepts": [
            "PhaseResult",
            "Iteration Count"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.4",
          "description": "Build prompt with TDD plan + beads issue IDs and execute Claude for 1 iteration.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "Claude is invoked with the constructed prompt.",
            "Claude's output is streamed to the console.",
            "The iteration count is incremented."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Execute Claude API call via `RunClaudeWithFile()`"
            ],
            "middleware": [],
            "shared": [
              "Prompt Template",
              "Claude API Key"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_1",
          "related_concepts": [
            "TDD Plan",
            "Beads Issue IDs",
            "Claude API",
            "Streaming Output"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.4.1",
          "description": "Loop through iterations (max 100) to check if all beads issues are closed.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The loop iterates up to 100 times.",
            "In each iteration, the status of all beads issues is checked.",
            "If all issues are closed, the loop breaks."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement loop logic.",
              "Implement status check for beads issues.",
              "Implement break condition."
            ],
            "middleware": [],
            "shared": [
              "Beads Issue Status Data",
              "Iteration Counter"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_2",
          "related_concepts": [
            "Claude Streaming Output",
            "Beads Issue Status",
            "Iteration Count"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.4.2",
          "description": "If all beads issues are closed, run tests and break the loop.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "If all beads issues are closed, the tests are executed.",
            "The tests are executed using `pytest` or `make test`.",
            "If the tests pass, the loop breaks.",
            "If the tests fail, the loop continues to the next iteration."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Execute tests using `pytest` or `make test`.",
              "Implement test result analysis."
            ],
            "middleware": [],
            "shared": [
              "Test Execution Command",
              "Test Results Data"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_3",
          "related_concepts": [
            "Test Execution",
            "pytest or make test",
            "Test Results"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.4.3",
          "description": "If tests fail, continue the loop to fix.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "If the tests fail, the loop continues to the next iteration.",
            "The prompt is modified based on the test results.",
            "The loop continues until all tests pass."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement prompt modification logic.",
              "Implement loop control."
            ],
            "middleware": [],
            "shared": [
              "Prompt Template",
              "Test Results Data"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_4",
          "related_concepts": [
            "Test Failure",
            "Debugging",
            "Prompt Modification"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.4.4",
          "description": "After loop completion, return PhaseResult with iteration count.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "A `PhaseResult` object is created.",
            "The `PhaseResult` object contains the iteration count.",
            "The `PhaseResult` object is returned."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create `PhaseResult` object.",
              "Populate `PhaseResult` with iteration count."
            ],
            "middleware": [],
            "shared": [
              "PhaseResult Template"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_5",
          "related_concepts": [
            "PhaseResult",
            "Iteration Count"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_000.5",
          "description": "Implement the autonomous loop for the implementation phase, iterating up to 100 times to invoke Claude and check for bead closure.",
          "type": "sub_process",
          "parent_id": "REQ_000",
          "children": [],
          "acceptance_criteria": [
            "The function executes the Claude API call with the generated prompt.",
            "The function sleeps for 10 seconds after each Claude API call.",
            "The function checks if all beads issues are closed (using a status check mechanism - e.g., API response or status code).",
            "If all beads are closed, the function executes tests (pytest or make test).",
            "If tests pass, the function breaks the loop and marks the phase complete.",
            "If tests fail, the function continues the loop to fix the tests.",
            "The function returns a `PhaseResult` with the iteration count.",
            "The function handles timeouts gracefully (e.g., if Claude doesn't respond).",
            "The function limits the maximum number of iterations to 100."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API call",
              "Test execution (pytest or make test)",
              "Status check (API response or status code)",
              "Loop control (iteration count, timeout)"
            ],
            "middleware": [
              "Concurrency (Goroutines)",
              "Timeouts"
            ],
            "shared": [
              "PhaseResult data structure",
              "Bead Status data structure"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementationLoop",
          "related_concepts": [
            "Claude API",
            "Bead Closure",
            "Test Execution",
            "Looping",
            "Concurrency (Goroutines)",
            "Timeouts"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_001",
      "description": "The Implementation Phase must use an autonomous loop pattern with maximum 100 iterations",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_001.1",
          "description": "Construct the prompt for Claude, incorporating the TDD plan and IDs of open beads issues. This ensures Claude understands the context and desired outcome.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The prompt includes the TDD plan details.",
            "The prompt includes all relevant IDs of open beads issues.",
            "The prompt is formatted according to Claude's prompt engineering guidelines."
          ],
          "implementation": {
            "frontend": [
              "UI component to display the TDD plan.",
              "UI component to display the beads issue IDs.",
              "UI component to input the prompt for Claude."
            ],
            "backend": [
              "API endpoint to retrieve the TDD plan.",
              "API endpoint to retrieve the beads issue IDs.",
              "Service to construct the Claude prompt."
            ],
            "middleware": [
              "Authentication middleware to verify user permissions.",
              "Request validation middleware to ensure data integrity."
            ],
            "shared": [
              "Data model for the TDD plan.",
              "Data model for the beads issue IDs.",
              "Constant for the Claude API endpoint."
            ]
          },
          "testable_properties": [],
          "function_id": "build_prompt_with_tdd_plan_and_beads_issue_ids",
          "related_concepts": [
            "TDD Plan",
            "Beads Issues",
            "Claude Prompt Engineering"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.1.1",
          "description": "Implement the autonomous loop to interact with Claude, iterating up to 100 times.  Within the loop, construct and send the prompt, wait for a response, and check if all beads issues are closed.  If not, continue the loop. If all issues are closed, run tests and break the loop.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The loop executes a maximum of 100 iterations.",
            "For each iteration, the Claude prompt is constructed correctly.",
            "The Claude API is called correctly to stream the output.",
            "The loop waits for 10 seconds between Claude calls.",
            "The loop checks if all beads issues are closed.",
            "If all issues are closed, the tests are executed correctly.",
            "If tests fail, the loop continues to the next iteration.",
            "If tests pass, the loop breaks and the phase result is returned."
          ],
          "implementation": {
            "frontend": [
              "UI component to display the Claude output in real-time.",
              "UI component to display the status of the loop (iteration count, status)."
            ],
            "backend": [
              "Service to call the Claude API with streaming output.",
              "Service to sleep for 10 seconds.",
              "Service to execute the tests (pytest or make test).",
              "Service to determine if the tests passed."
            ],
            "middleware": [
              "Rate limiting middleware to prevent excessive API calls.",
              "Error handling middleware to catch and log errors."
            ],
            "shared": [
              "Configuration for the Claude API.",
              "Constants for the sleep duration.",
              "Data model for the phase result."
            ]
          },
          "testable_properties": [],
          "function_id": "execute_claude_loop",
          "related_concepts": [
            "Claude API",
            "Streaming Output",
            "Test Execution",
            "Concurrency (Goroutines)",
            "Loop Control"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.1.2",
          "description": "Determine if all open beads issues have been resolved. This involves querying the beads issue system for the status of each issue and checking if all are closed.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The function retrieves the status of all open beads issues.",
            "The function accurately determines if all issues are closed.",
            "The function returns a boolean value indicating the status."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Service to call the beads issue system API.",
              "Service to parse the response from the beads issue system API."
            ],
            "middleware": [],
            "shared": [
              "Data model for the beads issue system API response."
            ]
          },
          "testable_properties": [],
          "function_id": "check_beads_issues_status",
          "related_concepts": [
            "Beads Issue System",
            "Issue Status",
            "API Calls",
            "Data Retrieval"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.1.3",
          "description": "Run the tests (pytest or make test) to verify the results of the Claude interaction.  If the tests pass, break the loop and mark the phase complete. If the tests fail, continue the loop to fix the issue.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The tests are executed using pytest or make test.",
            "The tests are executed with the correct inputs and configurations.",
            "The tests are executed in a consistent environment.",
            "The tests are executed with the correct dependencies.",
            "The tests are executed with the correct timeouts.",
            "The tests are executed with the correct logging levels.",
            "The tests are executed with the correct error handling."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Service to execute the tests (pytest or make test)."
            ],
            "middleware": [],
            "shared": [
              "Configuration for the test execution environment."
            ]
          },
          "testable_properties": [],
          "function_id": "execute_tests",
          "related_concepts": [
            "Test Execution",
            "pytest",
            "make test",
            "Test Result"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.2",
          "description": "This function implements the autonomous loop pattern for the implementation phase, iteratively invoking Claude with streaming output and checking for completion.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The function executes the Claude API with streaming output.",
            "The function sleeps for 10 seconds between Claude invocations.",
            "The function checks if all beads issues are closed after each Claude invocation.",
            "If all beads issues are closed, the function runs tests (pytest or make test) and breaks the loop if tests pass.",
            "If tests fail, the function continues the loop to fix the tests.",
            "The function returns a PhaseResult with the iteration count.",
            "The loop executes a maximum of 100 iterations.",
            "The function handles potential errors from the Claude API and tests.",
            "The function correctly manages the timeout for the Claude API calls."
          ],
          "implementation": {
            "frontend": [
              "UI component to display the loop iteration count.",
              "UI component to display the Claude streaming output.",
              "UI component to display the test results."
            ],
            "backend": [
              "API endpoint to trigger the Claude invocation.",
              "API endpoint to retrieve the Claude streaming output.",
              "API endpoint to retrieve the test results.",
              "Service to manage the Claude API calls.",
              "Service to manage the test execution.",
              "Service to manage the loop iteration count."
            ],
            "middleware": [
              "Rate limiting middleware to prevent excessive Claude API calls.",
              "Error handling middleware to catch and log errors from the Claude API."
            ],
            "shared": [
              "Data model for the PhaseResult.",
              "Configuration parameters for the Claude API.",
              "Constants for the loop iteration count and sleep duration."
            ]
          },
          "testable_properties": [],
          "function_id": "RunImplementationLoop",
          "related_concepts": [
            "Claude Streaming API",
            "Autonomous Loop Pattern",
            "Rate Limiting",
            "Error Handling"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.3",
          "description": "Execute the Claude loop to perform the implementation phase. This involves building the prompt, invoking Claude with streaming output, sleeping for 10 seconds, and checking if all beads issues are closed.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "Claude is invoked with the generated prompt.",
            "Claude's output is streamed to the console.",
            "The program sleeps for 10 seconds after each Claude invocation.",
            "The program checks if all beads issues are closed before proceeding to the next iteration.",
            "The loop executes a maximum of 100 iterations.",
            "The program returns a `PhaseResult` with the iteration count."
          ],
          "implementation": {
            "frontend": [
              "Console output for Claude's streaming response.",
              "UI elements for displaying the iteration count."
            ],
            "backend": [
              "Goroutine to handle Claude streaming.",
              "Timer to control the 10-second sleep.",
              "Function to check if all beads issues are closed (requires integration with Beads API).",
              "Function to build the Claude prompt.",
              "Function to generate the `PhaseResult`."
            ],
            "middleware": [
              "Error handling for Claude API calls.",
              "Rate limiting to prevent excessive Claude API calls."
            ],
            "shared": [
              "Claude API client library.",
              "Data models for the Claude prompt and `PhaseResult`."
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_ITERATION",
          "related_concepts": [
            "Claude Streaming",
            "Beads Integration",
            "Looping",
            "Timeouts"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.3.1",
          "description": "Construct the Claude prompt based on the TDD plan and bead issue IDs. This includes formatting the prompt for optimal Claude performance.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The prompt includes the TDD plan and all relevant bead issue IDs.",
            "The prompt is formatted according to Claude's best practices.",
            "The prompt is validated to ensure it contains the required information."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Function to format the TDD plan and bead issue IDs into a Claude prompt.",
              "Function to validate the prompt."
            ],
            "middleware": [],
            "shared": [
              "Data models for the TDD plan and bead issue IDs."
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_BUILD_PROMPT",
          "related_concepts": [
            "Claude Prompt Engineering",
            "TDD Plan",
            "Bead Issue IDs"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.3.2",
          "description": "Determine if all bead issues are closed. This requires integration with the Beads API to query the status of each issue.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The program successfully connects to the Beads API.",
            "The program retrieves the status of all bead issues.",
            "The program determines if all issues are closed.",
            "The program returns a boolean indicating whether all issues are closed."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Function to call the Beads API to retrieve issue statuses.",
              "Function to parse the API response.",
              "Function to determine if all issues are closed."
            ],
            "middleware": [
              "Error handling for API calls.",
              "Rate limiting to prevent excessive API calls."
            ],
            "shared": [
              "Beads API client library.",
              "Data models for the Beads API response."
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_CHECK_BEAD_ISSUE_STATUS",
          "related_concepts": [
            "Beads API",
            "Bead Issue Status",
            "API Integration"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.4",
          "description": "This function implements the core autonomous loop for the implementation phase. It constructs a prompt for Claude, sleeps for 10 seconds, and checks if all beads issues are closed before iterating again.  It also handles the loop termination condition.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The function correctly constructs the Claude prompt with the TDD plan and beads issue IDs.",
            "The function sleeps for 10 seconds.",
            "The function accurately checks if all beads issues are closed (using a reliable method - e.g., API call to beads service).",
            "The function terminates the loop after 100 iterations.",
            "The function correctly returns the PhaseResult with the iteration count."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this function."
            ],
            "backend": [
              "Call to Claude API (streaming output)",
              "Sleep function (using time.Sleep)",
              "Beads Issue Status Check (API call)",
              "PhaseResult construction"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "TDD Plan",
              "Beads Issue IDs",
              "PhaseResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_ITERATION",
          "related_concepts": [
            "Claude API",
            "Beads Integration",
            "Loop Control",
            "Concurrency"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.4.1",
          "description": "This function handles the loop termination conditions, ensuring the loop runs for a maximum of 100 iterations or until all beads issues are closed.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The function correctly limits the loop iterations to 100.",
            "The function correctly terminates the loop when all beads issues are closed.",
            "The function accurately tracks the iteration count."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this function."
            ],
            "backend": [
              "Iteration Counter",
              "Beads Issue Status Check (API call)",
              "Loop Control Logic"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Iteration Count",
              "Beads Issue IDs",
              "PhaseResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_TERMINATION",
          "related_concepts": [
            "Loop Control",
            "Iteration Count",
            "Beads Integration",
            "Concurrency"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.4.2",
          "description": "This function handles the loop termination condition due to a timeout (36 seconds).  It ensures the loop doesn't run indefinitely if the beads issues are not resolved within the timeout period.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The function correctly terminates the loop after 36 seconds if all beads issues are not closed.",
            "The function accurately tracks the elapsed time."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this function."
            ],
            "backend": [
              "Timer",
              "Beads Issue Status Check (API call)",
              "Loop Control Logic"
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Timer",
              "Beads Issue IDs",
              "PhaseResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_TERMINATION_TIMEOUT",
          "related_concepts": [
            "Loop Control",
            "Timeout",
            "Beads Integration",
            "Concurrency"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_001.5",
          "description": "Execute the autonomous implementation loop, iterating up to 100 times to invoke Claude and check for bead closure.",
          "type": "sub_process",
          "parent_id": "REQ_001",
          "children": [],
          "acceptance_criteria": [
            "The loop executes 100 times or until all beads are closed.",
            "Each iteration invokes Claude with the current TDD plan and issue IDs.",
            "Claude's output is streamed and processed.",
            "The script sleeps for 10 seconds after each Claude invocation.",
            "The script checks if all beads issues are closed after each sleep.",
            "If all beads are closed, the script runs tests (pytest or make test).",
            "If tests pass, the loop breaks, and the phase is marked complete.",
            "If tests fail, the loop continues to fix the issues.",
            "The iteration count is recorded and returned as part of the phase result.",
            "The script handles potential errors during Claude invocation and test execution."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API integration",
              "Test execution framework (pytest or make test)",
              "Loop control logic"
            ],
            "middleware": [
              "Error handling",
              "Logging"
            ],
            "shared": [
              "TDD plan data",
              "Bead issue IDs",
              "Test results"
            ]
          },
          "testable_properties": [],
          "function_id": "RunImplementationLoop",
          "related_concepts": [
            "Claude API",
            "Bead Closure",
            "Test Execution",
            "Looping",
            "Concurrency"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_002",
      "description": "The Implementation Phase must return PhaseResult with iteration count and test status",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_002.1",
          "description": "Track the number of loop iterations during TDD implementation phase execution, incrementing on each Claude invocation and storing final count in the result structure",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "Iterations field is initialized to 0 at the start of StepImplementation",
            "Iterations field increments by 1 before each Claude invocation",
            "Iterations field contains the final count when the loop terminates (success or failure)",
            "Iterations count is preserved in ImplementationResult JSON serialization",
            "Iterations count respects max_iterations limit (default 100)",
            "Iteration count is logged/printed at each loop iteration for observability",
            "If loop exits early due to success, iterations reflects actual iterations run, not max"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add Iterations int field to ImplementationResult struct in implementation.go",
              "Initialize result.Iterations = 0 before entering the while loop",
              "Increment result.Iterations++ at the start of each loop iteration",
              "Add fmt.Printf statement to display current iteration number",
              "Ensure Iterations is included in JSON struct tag: `json:\"iterations\"`"
            ],
            "middleware": [],
            "shared": [
              "Define IMPL_MAX_ITERATIONS constant (100) in implementation.go",
              "ImplementationResult struct must be defined with proper JSON tags for serialization"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.TrackIterationCount",
          "related_concepts": [
            "autonomous_loop",
            "claude_invocation",
            "max_iterations",
            "loop_termination",
            "progress_tracking"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_002.2",
          "description": "Track whether the final test suite execution passed after all beads issues are closed, storing boolean status and test output for debugging",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "TestsPassed bool field exists in ImplementationResult struct",
            "runTests function returns (bool, string) tuple for pass status and output",
            "pytest -v --tb=short is tried first with 300 second timeout",
            "make test is used as fallback if pytest is not found",
            "If neither test command exists, returns (true, 'No test command found, skipping')",
            "Tests are only run after all beads issues are confirmed closed",
            "If tests fail, loop continues to next iteration (does not break)",
            "If tests pass, loop terminates and TestsPassed is set to true",
            "Test output is captured and available for error reporting",
            "TestsPassed field is serialized to JSON with tag `json:\"tests_passed\"`"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add TestsPassed bool field to ImplementationResult struct",
              "Implement runTests(projectPath string) (bool, string) function",
              "Use exec.Command for pytest with -v and --tb=short flags",
              "Implement fallback to exec.Command for make test",
              "Capture CombinedOutput() for both stdout and stderr",
              "Set result.TestsPassed = passed after runTests call",
              "Print test failure output to console when tests fail",
              "Clear previous errors and break loop only when tests pass"
            ],
            "middleware": [],
            "shared": [
              "Import os/exec package for subprocess execution",
              "Import time package for timeout handling"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.TrackTestsPassedStatus",
          "related_concepts": [
            "pytest",
            "make_test",
            "test_verification",
            "test_output_capture",
            "red_green_refactor"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_002.3",
          "description": "Track which beads phase issues have been closed during implementation, storing closed issue IDs for progress monitoring and completion verification",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "PhasesClosed []string field exists in ImplementationResult struct",
            "checkAllIssuesClosed function checks each issue ID via bd show command",
            "Issue is considered closed if output contains 'status: closed' or 'status: done' (case insensitive)",
            "Function returns true only when ALL issue IDs are in closed/done status",
            "bd show command has 30 second timeout per issue",
            "If bd command fails or times out, assume issue is not closed (return false)",
            "PhasesClosed is populated with closed issue IDs for reporting",
            "Empty issue_ids list returns true (no issues to check)",
            "PhasesClosed field serializes to JSON with tag `json:\"phases_closed,omitempty\"`"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add PhasesClosed []string field to ImplementationResult struct",
              "Implement checkAllIssuesClosed(projectPath string, issueIDs []string) bool function",
              "Execute bd show <id> for each issue ID using exec.Command",
              "Set cmd.Dir = projectPath for correct working directory",
              "Convert output to lowercase using strings.ToLower",
              "Check for 'status: closed' or 'status: done' in output",
              "Track closed issues in result.PhasesClosed slice",
              "Return false immediately if any issue is not closed",
              "Handle errors gracefully by returning false on any failure"
            ],
            "middleware": [],
            "shared": [
              "Import strings package for ToLower and Contains operations",
              "Import os/exec for bd command execution"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.TrackPhasesClosed",
          "related_concepts": [
            "beads_issues",
            "bd_show",
            "issue_status",
            "completion_check",
            "epic_tracking"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_002.4",
          "description": "Track overall success/failure status of the implementation phase with detailed error messages for debugging and checkpoint persistence",
          "type": "sub_process",
          "parent_id": "REQ_002",
          "children": [],
          "acceptance_criteria": [
            "Success bool field exists and defaults to true at initialization",
            "Error string field captures failure reason",
            "Success is set to false when max_iterations is reached",
            "Success is set to false when tests fail on final iteration",
            "Error message includes max iterations count when loop exhausted",
            "Error message includes test failure details when tests fail",
            "Success remains true when all issues closed AND tests pass",
            "Claude invocation failures are logged but do not immediately set Success=false (loop continues)",
            "ImplementationResult is returned from StepImplementation function",
            "Success and Error fields serialize to JSON properly",
            "Result integrates with PipelineResult structure for overall pipeline tracking"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Initialize result := &ImplementationResult{Success: true} at function start",
              "Set result.Success = false and result.Error when max iterations reached",
              "Set result.Error = fmt.Sprintf('Max iterations (%d) reached', maxIterations)",
              "On Claude failure, log error but continue loop (transient failures)",
              "On test failure after issues closed, log but continue loop",
              "Only return success when issues closed AND tests pass",
              "Ensure result.Success and result.Error are mutually consistent"
            ],
            "middleware": [],
            "shared": [
              "ImplementationResult struct definition with Success bool `json:\"success\"` and Error string `json:\"error,omitempty\"`",
              "Import fmt package for error formatting",
              "Align with existing PipelineResult pattern in models.go"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.TrackSuccessErrorStatus",
          "related_concepts": [
            "error_handling",
            "phase_result",
            "loop_termination",
            "max_iterations",
            "checkpoint_manager"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_003",
      "description": "The system must implement a full Checkpoint System with UUID-based checkpoint files",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_003.1",
          "description": "Create UUID-based checkpoint files in .rlm-act-checkpoints/*.json that capture complete pipeline state after each phase",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "Checkpoint files are created in `.rlm-act-checkpoints/` directory relative to project root",
            "Each checkpoint file is named with a UUID v4 format: `{uuid}.json`",
            "Checkpoint JSON contains required fields: id, phase, timestamp, state, errors, git_commit",
            "Timestamp is in RFC3339/ISO8601 format with timezone suffix (e.g., `2026-01-09T20:53:34Z`)",
            "State field contains complete PipelineState serialized via `to_checkpoint_dict()` equivalent",
            "Git commit hash is captured from current HEAD (40-character SHA-1) or empty string if not in git repo",
            "Errors field is an array of error message strings (empty array if no errors)",
            "Checkpoint directory is created automatically if it doesn't exist (mode 0755)",
            "Checkpoint files are written with mode 0644",
            "Function returns absolute path to created checkpoint file",
            "WriteCheckpoint accepts PipelineState, phase name (string), and optional error list parameters"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create `go/internal/checkpoints/manager.go` with CheckpointManager struct",
              "Implement `NewCheckpointManager(projectPath string) *CheckpointManager` constructor",
              "Implement `WriteCheckpoint(state *PipelineState, phase string, errors []string) (string, error)` method",
              "Use `github.com/google/uuid` for UUID v4 generation",
              "Implement `getGitCommit(projectPath string) string` helper using `git rev-parse HEAD`",
              "Create Checkpoint struct with ID, Phase, Timestamp, State, Errors, GitCommit fields",
              "Use `json.MarshalIndent` for pretty-printed JSON output"
            ],
            "middleware": [],
            "shared": [
              "Define `Checkpoint` struct in `go/internal/checkpoints/types.go`",
              "Create constants: `CheckpointsDir = \".rlm-act-checkpoints\"`",
              "Add PipelineState serialization methods if not already present in models.go",
              "Add PhaseType and PhaseStatus enums to match Python implementation"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.WriteCheckpoint",
          "related_concepts": [
            "UUID generation",
            "JSON serialization",
            "PipelineState",
            "PhaseResult",
            "git commit tracking",
            "filesystem operations"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.2",
          "description": "Automatically trigger checkpoint creation after successful completion of each pipeline phase",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "Checkpoint is written automatically after each phase completes (success or failure)",
            "Phase name in checkpoint follows pattern: `{phase_type}-{status}` (e.g., `research-complete`, `decomposition-failed`)",
            "Checkpoint includes all phase results accumulated up to that point",
            "If checkpoint write fails, error is logged but pipeline continues (non-blocking)",
            "Checkpoint is written BEFORE user prompt in checkpoint autonomy mode",
            "Pipeline Run() method integrates CheckpointManager instance",
            "Each step (Research, Decomposition, Planning, PhaseDecomposition, BeadsIntegration, Implementation) triggers checkpoint",
            "PipelineConfig includes CheckpointManager reference or creates one internally"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Update `PlanningPipeline` struct to include `checkpointManager *CheckpointManager` field",
              "Create `writePhaseCheckpoint(phase string, state *PipelineState, errors []string)` private method",
              "Modify `Run()` method to call `writePhaseCheckpoint()` after each step",
              "Add `PipelineState` field to PipelineResults or create new state tracking structure",
              "Implement conversion from current `PipelineResults` to `PipelineState` for checkpoint compatibility",
              "Add error logging (not failure) for checkpoint write errors",
              "Update `PipelineConfig` to optionally accept pre-configured CheckpointManager"
            ],
            "middleware": [],
            "shared": [
              "Define phase name constants: PHASE_RESEARCH, PHASE_DECOMPOSITION, PHASE_PLANNING, etc.",
              "Define status suffixes: STATUS_COMPLETE, STATUS_FAILED, STATUS_IN_PROGRESS"
            ]
          },
          "testable_properties": [],
          "function_id": "PlanningPipeline.AutoCheckpointAfterPhase",
          "related_concepts": [
            "pipeline orchestration",
            "phase lifecycle",
            "checkpoint integration",
            "error handling",
            "phase names"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.3",
          "description": "Load and restore pipeline state from any checkpoint file to resume execution from that phase",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "DetectResumableCheckpoint() returns most recent checkpoint based on timestamp field (not file mtime)",
            "Returns nil/empty if no checkpoints exist or directory doesn't exist",
            "Checkpoint data includes `file_path` field pointing to source file",
            "LoadCheckpoint(checkpointPath string) deserializes JSON and returns PipelineState",
            "LoadCheckpoint returns error if file doesn't exist, is invalid JSON, or missing required fields",
            "GetCheckpointAgeDays(checkpoint) calculates age from timestamp field handling ISO8601 with Z suffix",
            "Resume skips phases that are already marked complete in the loaded state",
            "Resume starts execution from the first incomplete or failed phase",
            "Loaded checkpoint_id is preserved in resumed state",
            "beads_epic_id is restored for continued beads integration"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement `DetectResumableCheckpoint() (*Checkpoint, error)` method",
              "Implement `LoadCheckpoint(checkpointPath string) (*PipelineState, error)` method",
              "Implement `GetCheckpointAgeDays(checkpoint *Checkpoint) int` method",
              "Add timestamp parsing with ISO8601/RFC3339 handling including Z suffix conversion",
              "Sort checkpoints by timestamp descending (newest first)",
              "Handle JSON decode errors gracefully (skip corrupt files)",
              "Update `PlanningPipeline.Run()` or create `PlanningPipeline.Resume()` to accept loaded state",
              "Add phase skip logic based on PhaseStatus == COMPLETE in loaded state"
            ],
            "middleware": [],
            "shared": [
              "Implement `PipelineState.FromCheckpointDict(data map[string]interface{}) *PipelineState`",
              "Implement `PhaseResult.FromDict(data map[string]interface{}) *PhaseResult`",
              "Add `IsPhaseComplete(phaseType string) bool` method to PipelineState"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.ResumeFromCheckpoint",
          "related_concepts": [
            "checkpoint detection",
            "PipelineState deserialization",
            "phase skipping",
            "resume logic",
            "checkpoint selection"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.4",
          "description": "Delete checkpoint files older than a specified number of days based on their timestamp",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "CleanupByAge(days int) deletes all checkpoints with age >= days",
            "Age is calculated from checkpoint timestamp field, not filesystem modification time",
            "Returns tuple (deletedCount int, failedCount int)",
            "Gracefully handles missing/empty checkpoints directory (returns 0, 0)",
            "Skips files with invalid JSON (counts in failed)",
            "Skips files that fail to delete (counts in failed)",
            "Does not delete checkpoint files with missing or unparseable timestamps",
            "Days parameter of 0 deletes all checkpoints created before today",
            "Negative days parameter returns error or is treated as 0"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement `CleanupByAge(days int) (int, int)` method on CheckpointManager",
              "Use `filepath.Glob` to find all `*.json` files in checkpoints directory",
              "Read and parse each checkpoint file to extract timestamp",
              "Calculate age using `time.Now()` and parsed timestamp",
              "Call `os.Remove()` for files meeting age criteria",
              "Track deleted and failed counts separately",
              "Handle concurrent access edge cases (file deleted between read and delete)"
            ],
            "middleware": [],
            "shared": [
              "Reuse `GetCheckpointAgeDays()` method for age calculation",
              "Add date parsing utilities for ISO8601 timestamps"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.CleanupByAge",
          "related_concepts": [
            "checkpoint maintenance",
            "age calculation",
            "file deletion",
            "batch cleanup"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_003.5",
          "description": "Delete all checkpoint files in the checkpoints directory regardless of age",
          "type": "sub_process",
          "parent_id": "REQ_003",
          "children": [],
          "acceptance_criteria": [
            "CleanupAll() deletes all `*.json` files in `.rlm-act-checkpoints/` directory",
            "Returns tuple (deletedCount int, failedCount int)",
            "Gracefully handles missing checkpoints directory (returns 0, 0)",
            "Does NOT delete the checkpoints directory itself",
            "Does NOT delete non-JSON files in the directory",
            "Continues processing remaining files if one deletion fails",
            "Tracks both successful deletions and failures",
            "Can be called safely when no checkpoints exist"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement `CleanupAll() (int, int)` method on CheckpointManager",
              "Use `filepath.Glob` with pattern `*.json` in checkpoints directory",
              "Iterate through matched files calling `os.Remove()` on each",
              "Track deleted count for successful removals",
              "Track failed count for removal errors",
              "Return early with (0, 0) if directory doesn't exist",
              "Add CLI command integration: `context-engine checkpoint cleanup --all`"
            ],
            "middleware": [],
            "shared": [
              "Add DeleteCheckpoint(checkpointPath string) bool helper method",
              "Define CLI command structure for checkpoint management"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.CleanupAll",
          "related_concepts": [
            "checkpoint reset",
            "directory cleanup",
            "bulk deletion"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_004",
      "description": "The system must implement CWA (Context Window Array) Integration with all five components",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_004.1",
          "description": "Implement the autonomous loop pattern for the implementation phase, mimicking the Python code's behavior. This involves repeatedly invoking Claude with a prompt, sleeping for a specified duration, and checking for completion based on bead status.",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "The code executes the loop for a maximum of 100 iterations.",
            "Each iteration invokes Claude with the current prompt.",
            "The code sleeps for 10 seconds after each Claude invocation.",
            "The code checks if all beads issues are closed before proceeding to the next iteration.",
            "If all beads issues are closed, the code runs tests (pytest or make test) and breaks the loop if tests pass.",
            "If tests fail, the code continues to the next iteration to fix the issue.",
            "The code returns a PhaseResult with the iteration count.",
            "The code handles timeouts gracefully (e.g., if Claude doesn't respond within a certain time)."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API call",
              "Test execution (pytest or make test)",
              "Loop control logic"
            ],
            "middleware": [
              "Timeout handling",
              "Error handling"
            ],
            "shared": [
              "Prompt template",
              "Bead status tracking",
              "Test execution command"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Autonomous Loop",
            "Claude API",
            "Bead Status",
            "Timeouts",
            "Concurrency (Goroutines)"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.2",
          "description": "Implement the autonomous loop pattern for the implementation phase, iterating up to 100 times to invoke Claude with the TDD plan and beads issue IDs, sleeping for 10 seconds between iterations, and checking if all beads issues are closed before running tests. If tests fail, continue looping.  Return a PhaseResult with the iteration count.",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "The code correctly constructs the Claude prompt with the TDD plan and beads issue IDs.",
            "The code iterates up to 100 times.",
            "The code sleeps for 10 seconds between iterations.",
            "The code checks if all beads issues are closed before running tests.",
            "If tests pass, the loop breaks and a PhaseResult is returned with the iteration count.",
            "If tests fail, the loop continues to fix the tests.",
            "The code returns a PhaseResult with the iteration count.",
            "Tests pass when all beads issues are closed and tests pass."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API call",
              "Test execution (pytest)",
              "Loop control logic"
            ],
            "middleware": [],
            "shared": [
              "PhaseResult",
              "TDD Plan",
              "Beads Issue IDs"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Claude API",
            "TDD Plan",
            "Beads Issue IDs",
            "pytest",
            "TestableProperty",
            "PhaseResult"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.3",
          "description": "Implement the autonomous loop pattern for the implementation phase, iterating up to 100 times to query Claude with the TDD plan and beads issue IDs, sleeping for 10 seconds between each query, and checking if all beads issues are closed before running tests. If tests fail, continue looping.  If tests pass, break the loop and mark the phase complete. Return a phase result with the iteration count.",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "The loop iterates up to 100 times.",
            "Claude is invoked with the TDD plan and beads issue IDs in each iteration.",
            "A 10-second sleep is implemented between Claude queries.",
            "The code checks if all beads issues are closed before running tests.",
            "Tests are executed (pytest or make test) if all beads issues are closed.",
            "Tests pass before breaking the loop.",
            "If tests fail, the loop continues.",
            "The phase result includes the iteration count.",
            "The code handles potential errors during Claude API calls and test execution."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this phase."
            ],
            "backend": [
              "A Go function `RunClaudeWithFile()` to call the Claude API.",
              "A function to execute tests (pytest or make test).",
              "A function to generate the phase result."
            ],
            "middleware": [
              "Error handling middleware for Claude API calls and test execution."
            ],
            "shared": [
              "Data structures for storing the TDD plan and beads issue IDs.",
              "Constants for the loop sleep duration and maximum iterations.",
              "Error handling utilities."
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationPhaseLoop",
          "related_concepts": [
            "Autonomous Loop",
            "Claude API",
            "TDD Plan",
            "Beads Issues",
            "Test Execution",
            "Phase Result"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.4",
          "description": "Implement the autonomous loop pattern for the implementation phase, iterating up to 100 times to invoke Claude with the TDD plan and beads issue IDs, sleeping for 10 seconds between each invocation, and checking if all beads issues are closed before running tests. If tests fail, continue the loop. If tests pass, break the loop and mark the phase complete.",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "The code implements the autonomous loop pattern as described.",
            "The loop iterates up to 100 times.",
            "Claude is invoked with the TDD plan and beads issue IDs in each iteration.",
            "A 10-second sleep is implemented between Claude invocations.",
            "The code checks if all beads issues are closed before running tests.",
            "If tests fail, the loop continues to fix the issues.",
            "If tests pass, the loop breaks and the phase is marked complete.",
            "Tests are executed using pytest or make test.",
            "The code handles streaming output from Claude."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this function."
            ],
            "backend": [
              "A Go function `RunClaudeWithFile()` is created to invoke Claude with the provided prompt.",
              "A goroutine is used to handle the Claude API calls concurrently.",
              "A timer is used to sleep for 10 seconds between Claude invocations.",
              "A function to check if all beads issues are closed is implemented.",
              "A function to execute tests using pytest or make test is implemented.",
              "A function to mark the phase complete is implemented."
            ],
            "middleware": [
              "No middleware components are required for this function."
            ],
            "shared": [
              "A constant `IMPL_LOOP_SLEEP` is defined to store the sleep duration (10 seconds).",
              "A constant `IMPL_MAX_ITERATIONS` is defined to store the maximum number of iterations (100).",
              "A constant `IMPL_TIMEOUT` is defined to store the timeout duration (36 seconds)."
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Claude API",
            "TDD Plan",
            "Beads Issue IDs",
            "pytest",
            "Make Test",
            "Streaming Output",
            "Goroutines",
            "Concurrency"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_004.5",
          "description": "Implement the autonomous loop pattern for the implementation phase, including Claude invocation, sleep, and test execution.",
          "type": "sub_process",
          "parent_id": "REQ_004",
          "children": [],
          "acceptance_criteria": [
            "The code correctly invokes Claude with the TDD plan and beads issue IDs.",
            "The code implements a loop that iterates up to 100 times.",
            "The code sleeps for 10 seconds between Claude invocations.",
            "The code checks if all beads issues are closed before running tests.",
            "If tests pass, the loop breaks and the phase completes successfully.",
            "If tests fail, the loop continues to fix the issues.",
            "The code returns a PhaseResult with the iteration count.",
            "The code handles potential errors during Claude invocation and test execution."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this phase."
            ],
            "backend": [
              "A Go function `RunClaudeWithFile()` to interact with the Claude API.",
              "A function `RunClaudeWithFile()` to handle the loop and Claude invocation.",
              "A function `RunClaudeWithFile()` to manage the loop and Claude interaction.",
              "A function `RunClaudeWithFile()` to manage the loop and Claude interaction.",
              "A function `RunClaudeWithFile()` to manage the loop and Claude interaction.",
              "A function `RunClaudeWithFile()` to manage the loop and Claude interaction."
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Data models for Claude responses.",
              "Error handling mechanisms."
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Claude API",
            "Streaming Output",
            "pytest",
            "Make Test",
            "Looping",
            "Concurrency"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_005",
      "description": "The system must support Interactive Checkpoints with user prompts and input collection",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_005.1",
          "description": "Implement phase action prompts for research, decomposition, and TDD planning phases with menu-driven user interaction in Go",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "prompt_research_action() equivalent displays menu with Continue, Revise, Start over, Exit options",
            "prompt_decomposition_action() equivalent displays menu with Continue, Revise, Start over, Exit options",
            "prompt_tdd_planning_action() equivalent displays menu with Continue, Revise, Start over, Exit options",
            "All prompt functions accept single-key input (c/r/s/e) case-insensitive",
            "Empty input defaults to 'continue' action",
            "Invalid input displays error message and re-prompts without exiting",
            "Each function returns a PhaseAction enum or string: 'continue', 'revise', 'restart', 'exit'",
            "Menu text matches phase context (e.g., 'Continue to decomposition' vs 'Continue to multi-doc generation')",
            "prompt_phase_continue() displays completed phase name, artifacts list, and prompts Y/n to continue",
            "When user answers 'n' to continue, prompts for multiline feedback and returns {continue: false, feedback: string}",
            "prompt_use_checkpoint() displays timestamp, phase name, artifact list and prompts Y/n to resume",
            "All prompts integrate with PipelineConfig.AutonomyMode to skip prompts when fully autonomous"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create go/internal/checkpoints/interactive.go package",
              "Define PhaseAction type with constants: ActionContinue, ActionRevise, ActionRestart, ActionExit",
              "Implement PromptResearchAction() PhaseAction function with input loop",
              "Implement PromptDecompositionAction() PhaseAction function with input loop",
              "Implement PromptTDDPlanningAction() PhaseAction function with input loop",
              "Implement PromptPhaseContinue(phaseName string, artifacts []string) PhaseActionResult struct",
              "Implement PromptUseCheckpoint(timestamp, phase string, artifacts []string) bool function",
              "Add helper function normalizeInput(s string) string for case-insensitive trimmed input",
              "Add helper function isValidAction(input string, validMap map[string]PhaseAction) bool"
            ],
            "middleware": [],
            "shared": [
              "Define PhaseAction type as string with const values in models.go or interactive.go",
              "Define PhaseActionResult struct with Continue bool and Feedback string fields",
              "Add validPhaseActions map[string]PhaseAction for each phase type"
            ]
          },
          "testable_properties": [],
          "function_id": "interactive.PromptPhaseAction",
          "related_concepts": [
            "AutonomyMode",
            "PhaseType",
            "terminal user input",
            "menu validation",
            "checkpoint control flow"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_005.2",
          "description": "Implement multiline input collection that reads lines until an empty line is entered, with optional prompt prefix",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "CollectMultilineInput(prompt string) string function reads from stdin using bufio.Scanner",
            "Optional prompt string is displayed before each input line",
            "Reading continues until user enters an empty line (just presses Enter)",
            "All non-empty lines are joined with newline characters",
            "Function returns the complete multiline string",
            "Handles EOF gracefully without panic",
            "Works correctly with terminal input including special characters",
            "Empty first line returns empty string immediately",
            "Leading/trailing whitespace on each line is preserved (not trimmed)",
            "Integration with PromptPhaseContinue for feedback collection when user declines to continue"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement CollectMultilineInput(prompt string) string in go/internal/checkpoints/interactive.go",
              "Use bufio.NewScanner(os.Stdin) for line-by-line reading",
              "Use strings.Builder for efficient string concatenation",
              "Display prompt using fmt.Print (not Println) before each Scan()",
              "Check scanner.Text() == '' to detect empty line terminator",
              "Call scanner.Err() after loop to check for read errors",
              "Return builder.String() with final newline trimmed if present"
            ],
            "middleware": [],
            "shared": [
              "No shared components required - self-contained function"
            ]
          },
          "testable_properties": [],
          "function_id": "interactive.CollectMultilineInput",
          "related_concepts": [
            "bufio.Scanner",
            "stdin reading",
            "feedback collection",
            "revision prompts",
            "string building"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_005.3",
          "description": "Implement interactive file selection menu that displays numbered file list with search, custom path, and exit options",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "PromptFileSelection(files []string, fileType string) (action string, selectedPath string) function signature",
            "Displays header with fileType in uppercase (e.g., 'SELECT RESEARCH FILE')",
            "Lists discovered files with 1-indexed numbers: [1] filename1.md, [2] filename2.md",
            "Shows 'No {fileType} files found.' when files slice is empty",
            "Displays menu options: [S] Search again, [O] Other (specify path), [E] Exit",
            "Numeric input selects corresponding file and returns ('selected', filepath)",
            "Input 's' or 'S' returns ('search', '') to trigger re-search with more days",
            "Input 'o' or 'O' returns ('other', '') to trigger custom path prompt",
            "Input 'e' or 'E' returns ('exit', '') to abort selection",
            "Invalid number outside range displays 'Invalid number. Enter 1-N'",
            "Invalid non-numeric input displays 'Invalid choice. Enter a number, S, O, or E.'",
            "Empty file list with numeric input displays 'No files available to select.'",
            "prompt_search_days(default int) int prompts 'Search how many days back? [N]:' and validates positive integer",
            "prompt_custom_path(fileType string) (string, error) prompts for path and validates existence"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement PromptFileSelection(files []string, fileType string) (string, string) in interactive.go",
              "Implement PromptSearchDays(defaultDays int) int with input validation loop",
              "Implement PromptCustomPath(fileType string) (string, error) with os.Stat existence check",
              "Use path/filepath for path expansion and validation",
              "Define FileSelectionAction constants: ActionSelected, ActionSearch, ActionOther, ActionExit",
              "Add displayFileList(files []string, fileType string) helper for consistent formatting",
              "Implement strconv.Atoi for numeric input parsing with error handling"
            ],
            "middleware": [],
            "shared": [
              "Define FileSelectionResult struct with Action string and Path string fields",
              "Reuse separator display constant (e.g., SeparatorLine = strings.Repeat('=', 60))"
            ]
          },
          "testable_properties": [],
          "function_id": "interactive.PromptFileSelection",
          "related_concepts": [
            "file discovery",
            "path validation",
            "menu navigation",
            "search refinement",
            "research file selection",
            "plan file selection"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_005.4",
          "description": "Implement autonomy mode selection prompt that displays implementation readiness info and offers CHECKPOINT, BATCH, or FULLY_AUTONOMOUS modes",
          "type": "sub_process",
          "parent_id": "REQ_005",
          "children": [],
          "acceptance_criteria": [
            "PromptAutonomyMode(phaseCount int, epicID string) AutonomyMode function signature",
            "Displays 60-character separator line with 'IMPLEMENTATION READY' header",
            "Shows 'Plan phases: N' with phaseCount value",
            "Shows 'Beads epic: {epicID}' with epic identifier",
            "Displays mode options with descriptions: [C]heckpoint - pause at each phase for review (recommended), [F]ully autonomous - run all phases without stopping, [B]atch - run groups of phases, pause between groups",
            "Input 'c' or 'C' or empty returns AutonomyCheckpoint (default)",
            "Input 'f' or 'F' returns AutonomyFullyAutonomous",
            "Input 'b' or 'B' returns AutonomyBatch",
            "Invalid input displays 'Invalid choice: '{input}'. Please enter C, F, or B.' and re-prompts",
            "AutonomyMode type defined as iota-based int with String() method returning 'checkpoint', 'fully_autonomous', 'batch'",
            "Integration with PipelineConfig to set AutonomyMode field before implementation phase"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement PromptAutonomyMode(phaseCount int, epicID string) AutonomyMode in interactive.go",
              "Add input validation loop with map[string]AutonomyMode for valid choices",
              "Display implementation readiness banner with phase and epic info",
              "Use fmt.Printf for formatted output with phase count and epic ID"
            ],
            "middleware": [],
            "shared": [
              "Define AutonomyMode type in go/internal/planning/models.go with iota constants",
              "Define AutonomyCheckpoint, AutonomyBatch, AutonomyFullyAutonomous constants",
              "Implement String() method on AutonomyMode for serialization",
              "Implement FromString(s string) (AutonomyMode, error) for deserialization",
              "Update PipelineConfig struct to include AutonomyMode field instead of just AutoApprove bool",
              "Add validAutonomyModes map[string]AutonomyMode for input validation"
            ]
          },
          "testable_properties": [],
          "function_id": "interactive.PromptAutonomyMode",
          "related_concepts": [
            "AutonomyMode enum",
            "pipeline configuration",
            "phase count display",
            "beads epic integration",
            "execution mode selection"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_006",
      "description": "The system must support three Autonomy Modes: CHECKPOINT, BATCH, and FULLY_AUTONOMOUS",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_006.1",
          "description": "CHECKPOINT mode pauses after each phase, allowing user review and revision before proceeding to the next pipeline phase",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Pipeline execution pauses after EVERY phase (RESEARCH, DECOMPOSITION, TDD_PLANNING, MULTI_DOC, BEADS_SYNC, IMPLEMENTATION)",
            "User is prompted with phase-specific action menu (continue/revise/restart/exit) after each phase completion",
            "Phase artifacts are displayed to user before requesting action decision",
            "User can provide feedback for revision if choosing 'revise' action",
            "Checkpoint file is written to .rlm-act-checkpoints/ after each phase completes",
            "Pipeline can resume from any checkpoint if user exits mid-pipeline",
            "CHECKPOINT mode is the default mode when no mode is specified",
            "Auto-approve flag is FALSE when autonomy_mode == AutonomyCheckpoint"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement AutonomyCheckpoint constant (value = 0) in AutonomyMode type in models.go",
              "Add ShouldPauseAfterPhase(phase PhaseType, mode AutonomyMode) bool helper that returns true for CHECKPOINT mode",
              "Implement checkpoint pause logic in pipeline.go Run() method between each step",
              "Create PromptPhaseAction(phaseName string, artifacts []string) (action string, feedback string) in interactive.go",
              "Integrate CheckpointManager.WriteCheckpoint() call after each phase execution",
              "Add logic to handle 'revise', 'restart', and 'exit' actions from user prompts"
            ],
            "middleware": [],
            "shared": [
              "Define AutonomyMode type as iota enum with CHECKPOINT = 0",
              "Add String() method returning 'checkpoint' for AutonomyCheckpoint",
              "Add FromString(value string) (AutonomyMode, error) method for parsing CLI input",
              "Define PhaseAction constants: ActionContinue, ActionRevise, ActionRestart, ActionExit"
            ]
          },
          "testable_properties": [],
          "function_id": "AutonomyMode.CheckpointPause",
          "related_concepts": [
            "PipelineState",
            "PhaseType",
            "InteractivePrompts",
            "CheckpointManager",
            "UserReview"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.2",
          "description": "BATCH mode groups related phases together and pauses only between phase groups for streamlined execution",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "Phases are organized into logical groups: Planning Group (RESEARCH, DECOMPOSITION, TDD_PLANNING), Document Group (MULTI_DOC, BEADS_SYNC), Execution Group (IMPLEMENTATION)",
            "No pause occurs between phases within the same group",
            "User is prompted only at group boundaries (after Planning, after Documents, after Implementation)",
            "Group completion summary shows all artifacts produced by phases in that group",
            "User can choose to restart from the beginning of the current group",
            "Checkpoint is written at group boundaries, not at individual phase boundaries",
            "BATCH mode uses auto_approve=true for intra-group phases, auto_approve=false at group boundaries"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement AutonomyBatch constant (value = 1) in AutonomyMode type in models.go",
              "Define PhaseGroup struct with Name, Phases []PhaseType, and Description fields",
              "Create GetPhaseGroups() []PhaseGroup function returning the three groups: Planning, Documents, Execution",
              "Implement IsGroupBoundary(currentPhase, nextPhase PhaseType) bool helper function",
              "Add GetPhaseGroup(phase PhaseType) *PhaseGroup function to determine which group a phase belongs to",
              "Modify pipeline.go Run() to check IsGroupBoundary() instead of pausing after every phase",
              "Create PromptGroupAction(groupName string, phases []PhaseType, allArtifacts []string) (action string, feedback string)",
              "Implement group-level restart logic that clears results for all phases in current group"
            ],
            "middleware": [],
            "shared": [
              "Add AutonomyBatch constant to AutonomyMode enum",
              "Add String() method case returning 'batch' for AutonomyBatch",
              "Define PhaseGroup struct in models.go",
              "Define PHASE_GROUPS package-level variable with Planning/Documents/Execution groups"
            ]
          },
          "testable_properties": [],
          "function_id": "AutonomyMode.BatchGroupPause",
          "related_concepts": [
            "PhaseGroups",
            "BatchExecution",
            "GroupBoundary",
            "PipelineOrchestration"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.3",
          "description": "FULLY_AUTONOMOUS mode runs all phases without any user interaction or pauses",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "All 6 phases execute sequentially without any user prompts",
            "No interactive input is requested at any point during execution",
            "Auto-approve flag is TRUE for all phases when autonomy_mode == AutonomyFull",
            "Pipeline halts only on phase failure (error condition)",
            "Final summary is displayed only after all phases complete or pipeline fails",
            "Checkpoint files are still written after each phase for crash recovery",
            "Mode is suitable for CI/CD pipelines and unattended execution",
            "Timeout handling is automatic without user intervention"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement AutonomyFull constant (value = 2) in AutonomyMode type in models.go",
              "Add IsAutonomous(mode AutonomyMode) bool helper returning true for AutonomyFull",
              "Set autoApprove = true in all phase execution calls when mode == AutonomyFull",
              "Skip all PromptPhaseAction() calls when mode == AutonomyFull",
              "Skip all PromptGroupAction() calls when mode == AutonomyFull",
              "Implement automatic error handling and logging for failures in autonomous mode",
              "Add --autonomous or -a CLI flag mapped to AutonomyFull mode",
              "Ensure CheckpointManager.WriteCheckpoint() is called regardless of mode for crash recovery"
            ],
            "middleware": [],
            "shared": [
              "Add AutonomyFull constant to AutonomyMode enum",
              "Add String() method case returning 'fully_autonomous' for AutonomyFull",
              "Add IsInteractive() bool method to AutonomyMode returning false for AutonomyFull"
            ]
          },
          "testable_properties": [],
          "function_id": "AutonomyMode.FullyAutonomousExecution",
          "related_concepts": [
            "UnattendedExecution",
            "AutoApprove",
            "CIIntegration",
            "HeadlessMode"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_006.4",
          "description": "Implement the AutonomyMode enum type in Go with three values matching Python implementation",
          "type": "sub_process",
          "parent_id": "REQ_006",
          "children": [],
          "acceptance_criteria": [
            "AutonomyMode is defined as a custom int type with iota constants",
            "Three constants defined: AutonomyCheckpoint (0), AutonomyBatch (1), AutonomyFull (2)",
            "String() method returns lowercase string values matching Python: 'checkpoint', 'batch', 'fully_autonomous'",
            "FromString() static function parses string to AutonomyMode with error handling for invalid values",
            "JSON marshaling serializes to string value (not integer)",
            "JSON unmarshaling parses from string value",
            "AutonomyMode is added to PipelineConfig struct in pipeline.go",
            "Default value is AutonomyCheckpoint when not specified",
            "CLI parses --mode flag with values: checkpoint, batch, autonomous"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Update go/internal/cli/plan.go to add --mode/-m flag accepting 'checkpoint', 'batch', 'autonomous' values",
              "Parse mode flag and convert to AutonomyMode using FromString()",
              "Pass AutonomyMode to PipelineConfig when creating pipeline",
              "Update pipeline.go PipelineConfig struct to include AutonomyMode field",
              "Modify Run() method to use config.AutonomyMode for pause/continue decisions"
            ],
            "middleware": [],
            "shared": [
              "Create AutonomyMode type: type AutonomyMode int",
              "Define constants using iota: const (AutonomyCheckpoint AutonomyMode = iota; AutonomyBatch; AutonomyFull)",
              "Implement func (m AutonomyMode) String() string with switch statement",
              "Implement func AutonomyModeFromString(s string) (AutonomyMode, error)",
              "Implement func (m AutonomyMode) MarshalJSON() ([]byte, error)",
              "Implement func (m *AutonomyMode) UnmarshalJSON(data []byte) error",
              "Add helper methods: IsCheckpoint() bool, IsBatch() bool, IsAutonomous() bool",
              "Add ValidAutonomyModes map[string]bool for validation"
            ]
          },
          "testable_properties": [],
          "function_id": "Planning.AutonomyModeEnum",
          "related_concepts": [
            "EnumType",
            "TypeSafety",
            "PipelineConfig",
            "CLIFlags",
            "Serialization"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_007",
      "description": "The system must implement all data model mappings from Python to Go equivalents",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_007.1",
          "description": "Port AutonomyMode enum from Python to Go with string conversion methods and validation",
          "type": "sub_process",
          "parent_id": "REQ_007",
          "children": [],
          "acceptance_criteria": [
            "Define AutonomyMode as iota-based integer type in Go",
            "Implement three modes: AutonomyCheckpoint (pause after each phase), AutonomyBatch (pause between groups), AutonomyFull (no pauses)",
            "Implement String() method returning 'checkpoint', 'batch', or 'fully_autonomous' strings",
            "Implement FromString(string) (AutonomyMode, error) factory method for parsing string input",
            "Implement MarshalJSON() and UnmarshalJSON() for JSON serialization matching Python value format",
            "Return descriptive error for invalid string values listing valid options",
            "Maintain backward compatibility with existing AutoApprove bool flag (AutoApprove=true maps to AutonomyFull)",
            "Unit tests cover all three modes, string round-trip conversion, and error cases"
          ],
          "implementation": {
            "frontend": [],
            "backend": [],
            "middleware": [],
            "shared": [
              "Add AutonomyMode type definition to go/internal/planning/models.go",
              "Implement const block with AutonomyCheckpoint, AutonomyBatch, AutonomyFull iota values",
              "Implement String() method for AutonomyMode",
              "Implement FromString() parsing function with validation",
              "Implement MarshalJSON() returning quoted string value",
              "Implement UnmarshalJSON() parsing JSON string to enum",
              "Add IsValid() method for validation checks",
              "Update PipelineConfig struct to use AutonomyMode instead of/alongside AutoApprove bool"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.AutonomyMode",
          "related_concepts": [
            "execution_modes",
            "pipeline_control",
            "user_interaction",
            "batch_processing"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_007.2",
          "description": "Port PhaseType enum from Python to Go representing the 6 pipeline phases with ordering semantics",
          "type": "sub_process",
          "parent_id": "REQ_007",
          "children": [],
          "acceptance_criteria": [
            "Define PhaseType as iota-based integer type preserving execution order",
            "Implement six phases: PhaseResearch, PhaseDecomposition, PhaseTDDPlanning, PhaseMultiDoc, PhaseBeadsSync, PhaseImplementation",
            "Implement String() method returning 'research', 'decomposition', 'tdd_planning', 'multi_doc', 'beads_sync', 'implementation'",
            "Implement FromString(string) (PhaseType, error) factory method",
            "Implement Next() method returning the next phase in sequence (nil/error for Implementation)",
            "Implement Previous() method returning the prior phase (nil/error for Research)",
            "Implement MarshalJSON() and UnmarshalJSON() matching Python serialization format",
            "Implement AllPhases() function returning ordered slice of all phases",
            "Unit tests verify ordering, string conversion, JSON serialization, and navigation methods"
          ],
          "implementation": {
            "frontend": [],
            "backend": [],
            "middleware": [],
            "shared": [
              "Add PhaseType type definition to go/internal/planning/models.go",
              "Define const block with ordered iota values for 6 phases",
              "Implement String() method with switch statement for phase names",
              "Implement FromString() function with map lookup and error handling",
              "Implement Next() method returning subsequent phase or error at end",
              "Implement Previous() method returning prior phase or error at start",
              "Implement AllPhases() returning []PhaseType in execution order",
              "Add JSON marshaling methods for serialization compatibility"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PhaseType",
          "related_concepts": [
            "pipeline_phases",
            "execution_order",
            "phase_transitions",
            "checkpointing"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_007.3",
          "description": "Port PhaseStatus enum from Python to Go tracking phase execution state with transition validation",
          "type": "sub_process",
          "parent_id": "REQ_007",
          "children": [],
          "acceptance_criteria": [
            "Define PhaseStatus as iota-based integer type",
            "Implement four statuses: StatusPending, StatusInProgress, StatusComplete, StatusFailed",
            "Implement String() method returning 'pending', 'in_progress', 'complete', 'failed'",
            "Implement FromString(string) (PhaseStatus, error) factory method",
            "Implement IsTerminal() method returning true for Complete and Failed states",
            "Implement CanTransitionTo(PhaseStatus) bool method enforcing valid state transitions",
            "Implement MarshalJSON() and UnmarshalJSON() for checkpoint serialization",
            "Define valid state transitions: Pending\u2192InProgress, InProgress\u2192Complete|Failed, Failed\u2192InProgress (retry)",
            "Unit tests cover all states, string conversion, transition validation, and JSON serialization"
          ],
          "implementation": {
            "frontend": [],
            "backend": [],
            "middleware": [],
            "shared": [
              "Add PhaseStatus type definition to go/internal/planning/models.go",
              "Define const block with StatusPending, StatusInProgress, StatusComplete, StatusFailed",
              "Implement String() method returning lowercase status strings",
              "Implement FromString() function with validation",
              "Implement IsTerminal() returning true for Complete/Failed",
              "Implement CanTransitionTo() with valid transition map",
              "Add JSON marshaling for checkpoint compatibility",
              "Document state machine transitions in code comments"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PhaseStatus",
          "related_concepts": [
            "execution_state",
            "status_tracking",
            "state_machine",
            "checkpoint_resume"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_007.4",
          "description": "Port PhaseResult dataclass to Go StepResult struct with full field mapping and serialization",
          "type": "sub_process",
          "parent_id": "REQ_007",
          "children": [],
          "acceptance_criteria": [
            "Extend existing StepResult struct or create PhaseResult struct with all Python fields",
            "Include PhaseType field to identify which phase produced the result",
            "Include PhaseStatus field for execution state",
            "Include Artifacts []string for file paths produced by the phase",
            "Include Errors []string for error messages (not just single Error string)",
            "Include StartedAt *time.Time for execution start timestamp",
            "Include CompletedAt *time.Time for execution end timestamp",
            "Include DurationSeconds float64 computed from timing",
            "Include Metadata map[string]interface{} for extensible key-value data",
            "Implement IsComplete() bool helper method checking status",
            "Implement IsFailed() bool helper method checking status",
            "Implement ToDict() map[string]interface{} for checkpoint serialization matching Python format",
            "Implement FromDict(map[string]interface{}) (*PhaseResult, error) for deserialization",
            "JSON tags must match Python field names for cross-language checkpoint compatibility",
            "Unit tests verify serialization round-trip with Python-generated checkpoint data"
          ],
          "implementation": {
            "frontend": [],
            "backend": [],
            "middleware": [],
            "shared": [
              "Add PhaseResult struct to go/internal/planning/models.go with all required fields",
              "Add PhaseType and PhaseStatus fields using new enum types",
              "Add Artifacts, Errors slice fields for multi-value tracking",
              "Add StartedAt, CompletedAt as *time.Time pointers",
              "Add DurationSeconds computed or stored field",
              "Add Metadata map[string]interface{} for extensibility",
              "Implement IsComplete() and IsFailed() helper methods",
              "Implement ToDict() serialization method with ISO8601 time format",
              "Implement FromDict() deserialization factory function",
              "Implement MarshalJSON/UnmarshalJSON with custom time handling",
              "Ensure JSON field names match Python snake_case: phase_type, started_at, completed_at, duration_seconds"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PhaseResult",
          "related_concepts": [
            "execution_results",
            "artifact_tracking",
            "error_handling",
            "timing_metrics",
            "checkpointing"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_007.5",
          "description": "Port PipelineState dataclass to Go PipelineResults struct with full state tracking and CWA context entry support",
          "type": "sub_process",
          "parent_id": "REQ_007",
          "children": [],
          "acceptance_criteria": [
            "Extend PipelineResults struct or create PipelineState struct with all Python fields",
            "Include ProjectPath string for project root directory",
            "Include AutonomyMode field using new enum type",
            "Include CurrentPhase *PhaseType for in-progress phase tracking",
            "Include PhaseResults map[PhaseType]*PhaseResult for per-phase outcomes",
            "Include ContextEntryIDs map[PhaseType][]string for CWA integration tracking",
            "Include StartedAt *time.Time for pipeline start timestamp",
            "Include CheckpointID string for resume capability",
            "Include BeadsEpicID string for beads integration",
            "Include Metadata map[string]interface{} for extensible data",
            "Implement validation in constructor/SetProjectPath ensuring non-empty project path",
            "Implement GetPhaseResult(PhaseType) *PhaseResult accessor",
            "Implement SetPhaseResult(PhaseType, *PhaseResult) mutator",
            "Implement IsPhaseComplete(PhaseType) bool helper",
            "Implement AllPhasesComplete() bool checking all 6 phases",
            "Implement TrackContextEntry(PhaseType, entryID string) for CWA tracking",
            "Implement GetContextEntries(PhaseType) []string accessor",
            "Implement ToDict() serialization matching Python checkpoint format",
            "Implement ToCheckpointDict() alias for semantic clarity",
            "Implement FromDict() and FromCheckpointDict() deserialization",
            "Unit tests verify full state lifecycle, serialization compatibility with Python checkpoints"
          ],
          "implementation": {
            "frontend": [],
            "backend": [],
            "middleware": [],
            "shared": [
              "Add PipelineState struct to go/internal/planning/models.go",
              "Add ProjectPath string field with validation",
              "Add AutonomyMode field using new enum type",
              "Add CurrentPhase *PhaseType pointer for nullable tracking",
              "Add PhaseResults map[PhaseType]*PhaseResult for outcomes",
              "Add ContextEntryIDs map[PhaseType][]string for CWA integration (MANDATORY per requirements)",
              "Add StartedAt *time.Time for timing",
              "Add CheckpointID and BeadsEpicID string fields",
              "Add Metadata map[string]interface{} for extensibility",
              "Implement NewPipelineState(projectPath string, mode AutonomyMode) constructor with validation",
              "Implement GetPhaseResult, SetPhaseResult accessor/mutator methods",
              "Implement IsPhaseComplete checking status field",
              "Implement AllPhasesComplete iterating all PhaseType values",
              "Implement TrackContextEntry and GetContextEntries for CWA tracking",
              "Implement ToDict with proper enum-to-string and time-to-ISO8601 conversion",
              "Implement FromDict with proper string-to-enum and ISO8601-to-time parsing",
              "Add ToCheckpointDict/FromCheckpointDict aliases",
              "Ensure JSON keys match Python: project_path, autonomy_mode, current_phase, phase_results, context_entry_ids, started_at, checkpoint_id, beads_epic_id, metadata"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PipelineState",
          "related_concepts": [
            "pipeline_orchestration",
            "state_management",
            "checkpoint_resume",
            "cwa_integration",
            "beads_tracking"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_008",
      "description": "The system must implement all phase functions with correct Python to Go mappings",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_008.1",
          "description": "Implement the autonomous implementation loop, iterating up to 100 times to invoke Claude and check for bead closure.  This includes handling streaming output, sleep intervals, and test execution.",
          "type": "sub_process",
          "parent_id": "REQ_008",
          "children": [],
          "acceptance_criteria": [
            "The code executes the implementation loop for a maximum of 100 iterations.",
            "Each iteration invokes Claude with the appropriate prompt (including TDD plan and bead issue IDs).",
            "Claude's output is streamed and processed.",
            "A 10-second sleep interval is implemented.",
            "The code checks if all bead issues are closed after each Claude invocation.",
            "If all issues are closed, the code executes tests (pytest or make test).",
            "If tests pass, the loop breaks, and the phase is marked complete.",
            "If tests fail, the loop continues to fix the issues.",
            "The iteration count is recorded and returned as part of the PhaseResult.",
            "Test execution results are logged."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API calls",
              "Test execution command execution",
              "Logging"
            ],
            "middleware": [
              "Rate limiting (if necessary)",
              "Error handling"
            ],
            "shared": [
              "Prompt templates",
              "Test command definitions",
              "Logging configuration"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementation",
          "related_concepts": [
            "Claude Streaming",
            "Test Execution (pytest or make test)",
            "Bead Closure Detection",
            "Autonomous Loop Pattern"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_008.2",
          "description": "Implement the autonomous implementation loop to execute Claude prompts, monitor bead status, and run tests.",
          "type": "sub_process",
          "parent_id": "REQ_008",
          "children": [],
          "acceptance_criteria": [
            "The code executes the implementation loop for a maximum of 100 iterations.",
            "Each iteration invokes Claude with the TDD plan and bead issue IDs.",
            "Claude's output is streamed and processed in real-time.",
            "The code checks if all bead issues are closed after each Claude invocation.",
            "If all issues are closed, the code runs tests (pytest or make test).",
            "If tests pass, the loop breaks, and the phase is marked complete.",
            "If tests fail, the loop continues to fix the issue.",
            "The iteration count is recorded and returned as part of the phase result.",
            "The code handles potential errors and exceptions gracefully."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API Integration",
              "Test Execution (pytest or make test)",
              "Logging and Monitoring"
            ],
            "middleware": [
              "Rate Limiting (for Claude API)",
              "Error Handling"
            ],
            "shared": [
              "TDD Plan",
              "Bead Issue IDs",
              "Test Data",
              "Logging Configuration"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementation",
          "related_concepts": [
            "Claude API",
            "Bead Status",
            "pytest",
            "Make Test",
            "Autonomous Loop",
            "Streaming Output"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_008.3",
          "description": "Implement the autonomous implementation loop to execute Claude prompts, sleep, and check for bead closure. This function orchestrates the iterative execution of the implementation phase.",
          "type": "sub_process",
          "parent_id": "REQ_008",
          "children": [],
          "acceptance_criteria": [
            "The function correctly invokes Claude with the TDD plan and issue IDs.",
            "The function executes the loop for a maximum of 100 iterations.",
            "The function sleeps for 10 seconds between Claude invocations.",
            "The function accurately checks if all beads issues are closed before proceeding to the next iteration.",
            "If all beads issues are closed, the function executes tests (pytest or make test).",
            "If tests pass, the function breaks the loop and marks the phase complete.",
            "If tests fail, the function continues the loop to fix the failing tests.",
            "The function returns a PhaseResult with the iteration count."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API integration",
              "Test execution framework integration",
              "Loop management"
            ],
            "middleware": [
              "Concurrency control",
              "Rate limiting (if necessary)"
            ],
            "shared": [
              "TDD plan data",
              "Bead issue IDs",
              "Test results data"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementation",
          "related_concepts": [
            "Claude API",
            "Bead Closure",
            "Test Execution",
            "Concurrency",
            "Looping"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_008.4",
          "description": "Implement the autonomous implementation loop, iterating up to 100 times, to execute Claude with the TDD plan and beads issue IDs, checking for closed issues, and running tests if successful.",
          "type": "sub_process",
          "parent_id": "REQ_008",
          "children": [],
          "acceptance_criteria": [
            "The code correctly constructs the Claude prompt with the TDD plan and beads issue IDs.",
            "The code implements the loop, sleeping for 10 seconds between iterations.",
            "The code checks if all beads issues are closed within each iteration.",
            "If all issues are closed, the code runs tests (pytest or make test).",
            "If tests pass, the code breaks the loop and marks the phase as complete, incrementing the iteration count.",
            "If tests fail, the code continues the loop to fix the issues.",
            "The code returns a PhaseResult with the iteration count.",
            "The loop executes a maximum of 100 iterations."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API calls",
              "Test execution (pytest or make test)",
              "Loop control logic"
            ],
            "middleware": [
              "Rate limiting (if necessary)",
              "Error handling"
            ],
            "shared": [
              "TDD Plan data",
              "Beads Issue IDs",
              "Test Results"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementation",
          "related_concepts": [
            "Autonomous Loop",
            "Claude API",
            "TDD Plan",
            "Beads Integration",
            "Test Execution (pytest or make test)",
            "Iteration Count"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_008.5",
          "description": "Implement the autonomous implementation loop to execute Claude prompts, sleep, and check for bead closure. This function orchestrates the iterative process of interacting with Claude, monitoring progress, and triggering tests.",
          "type": "sub_process",
          "parent_id": "REQ_008",
          "children": [],
          "acceptance_criteria": [
            "The function successfully invokes Claude with the generated prompt.",
            "The function sleeps for 10 seconds after each Claude invocation.",
            "The function accurately checks if all beads issues are closed based on Claude's output.",
            "If all beads issues are closed, the function executes tests (pytest or make test).",
            "If tests pass, the function breaks the loop and marks the phase complete.",
            "If tests fail, the function continues the loop to fix the issue.",
            "The function returns a `PhaseResult` object with the iteration count."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API integration",
              "Test execution engine",
              "Logging and monitoring"
            ],
            "middleware": [
              "Rate limiting",
              "Error handling"
            ],
            "shared": [
              "Configuration parameters (sleep duration, max iterations)",
              "Error handling utilities"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementation",
          "related_concepts": [
            "Claude API",
            "Bead Closure",
            "Test Execution",
            "Autonomous Loop",
            "Streaming Output"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_009",
      "description": "The Claude Runner must support synchronous execution, file-based execution, and conversation mode",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_009.1",
          "description": "Implement synchronous Claude CLI execution with timeout support, stdin-based prompt delivery, and dual-mode output handling (streaming vs buffered)",
          "type": "sub_process",
          "parent_id": "REQ_009",
          "children": [],
          "acceptance_criteria": [
            "Function accepts prompt string, timeout in seconds, stream boolean flag, and working directory path",
            "Creates context with configurable timeout using context.WithTimeout",
            "Passes prompt via stdin pipe instead of -p flag to support large prompts",
            "Uses --print flag for CLI output mode",
            "Uses --output-format json flag when stream=false for structured output",
            "Returns ClaudeResult struct with Success, Output, and Error fields",
            "Handles context.DeadlineExceeded errors with descriptive timeout message",
            "Captures both stdout and stderr in separate goroutines",
            "Uses sync.WaitGroup to ensure all goroutines complete before returning",
            "Sets working directory via cmd.Dir for project-scoped execution",
            "Writes diagnostic debug logs to stderr for troubleshooting",
            "Flushes stdout buffer after streaming completes using os.Stdout.Sync()"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create ClaudeResult struct with Success bool, Output string, Error string fields",
              "Implement RunClaudeSync function with (prompt string, timeoutSecs int, stream bool, cwd string) signature",
              "Create context with timeout using context.WithTimeout(context.Background(), duration)",
              "Build command args array with --print flag and conditional --output-format json",
              "Create exec.CommandContext with claude binary and args",
              "Set cmd.Dir to cwd parameter for working directory",
              "Create stdin pipe using cmd.StdinPipe() for prompt delivery",
              "Create stdout pipe using cmd.StdoutPipe() for output capture",
              "Create stderr pipe using cmd.StderrPipe() for error capture",
              "Start command using cmd.Start() before writing to stdin",
              "Write prompt to stdin in goroutine and close pipe when done",
              "Use bufio.Scanner to read stdout line by line in goroutine",
              "Use bufio.Scanner to read stderr in separate goroutine",
              "Wait for command completion with cmd.Wait()",
              "Wait for all goroutines using sync.WaitGroup",
              "Check for timeout errors using ctx.Err() == context.DeadlineExceeded",
              "Return populated ClaudeResult with captured output or error"
            ],
            "middleware": [
              "Validate cwd path exists before execution",
              "Validate timeout is within acceptable range (0 < timeout <= 600 seconds)"
            ],
            "shared": [
              "ClaudeResult struct definition in models or claude_runner.go",
              "Constants for default timeout values",
              "Debug logging format strings for stderr output"
            ]
          },
          "testable_properties": [],
          "function_id": "ClaudeRunner.RunClaudeSync",
          "related_concepts": [
            "exec.CommandContext",
            "context.WithTimeout",
            "stdin/stdout pipes",
            "goroutines for I/O",
            "sync.WaitGroup",
            "ClaudeResult struct"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_009.2",
          "description": "Implement file-based Claude execution that reads file content and combines it with a prompt for context-aware LLM calls",
          "type": "sub_process",
          "parent_id": "REQ_009",
          "children": [],
          "acceptance_criteria": [
            "Function accepts prompt string, file path, timeout seconds, stream flag, and working directory",
            "Reads file content using os.ReadFile",
            "Returns error result if file read fails with descriptive error message",
            "Combines file content with prompt using structured format: 'File content from {path}:\\n```\\n{content}\\n```\\n\\n{prompt}'",
            "Delegates to RunClaudeSync with combined prompt",
            "Preserves all RunClaudeSync parameters (timeout, stream, cwd)",
            "Returns ClaudeResult with file read errors clearly distinguished from Claude execution errors"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement RunClaudeWithFile function with (prompt, filePath string, timeoutSecs int, stream bool, cwd string) signature",
              "Read file content using os.ReadFile(filePath)",
              "Handle file read error by returning ClaudeResult{Success: false, Error: formatted error}",
              "Format combined prompt using fmt.Sprintf with file path, content in markdown code block, and original prompt",
              "Call RunClaudeSync with combined prompt and pass-through parameters",
              "Return ClaudeResult from RunClaudeSync"
            ],
            "middleware": [
              "Validate file path is not empty",
              "Check file exists before attempting to read",
              "Consider file size limits to prevent memory issues with very large files"
            ],
            "shared": [
              "File content template format constant",
              "Maximum file size constant for safety limits"
            ]
          },
          "testable_properties": [],
          "function_id": "ClaudeRunner.RunClaudeWithFile",
          "related_concepts": [
            "os.ReadFile",
            "file content injection",
            "prompt templating",
            "RunClaudeSync delegation",
            "markdown code blocks"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_009.3",
          "description": "Implement multi-turn conversation support by formatting conversation history into a structured prompt for Claude execution",
          "type": "sub_process",
          "parent_id": "REQ_009",
          "children": [],
          "acceptance_criteria": [
            "Define ConversationMessage struct with Role and Content string fields",
            "Role field accepts 'user' or 'assistant' values",
            "Function accepts slice of ConversationMessage, timeout, stream flag, and working directory",
            "Formats messages with 'Human: ' prefix for user role",
            "Formats messages with 'Assistant: ' prefix for assistant role",
            "Separates messages with double newlines for clarity",
            "Uses strings.Builder for efficient string concatenation",
            "Delegates to RunClaudeSync with formatted conversation prompt",
            "Returns ClaudeResult from RunClaudeSync execution"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define ConversationMessage struct with Role string and Content string fields",
              "Add json struct tags: Role `json:\"role\"` and Content `json:\"content\"`",
              "Implement RunClaudeConversation with (messages []ConversationMessage, timeoutSecs int, stream bool, cwd string) signature",
              "Create strings.Builder for prompt construction",
              "Iterate over messages slice",
              "Check msg.Role == 'user' to prepend 'Human: ' prefix",
              "Check msg.Role == 'assistant' to prepend 'Assistant: ' prefix",
              "Append msg.Content after role prefix",
              "Append '\\n\\n' after each message for separation",
              "Call RunClaudeSync with promptBuilder.String() and pass-through parameters",
              "Return ClaudeResult from RunClaudeSync"
            ],
            "middleware": [
              "Validate messages slice is not empty",
              "Validate each message has non-empty content",
              "Validate role is either 'user' or 'assistant'"
            ],
            "shared": [
              "ConversationMessage struct definition",
              "Role constants: RoleUser = 'user', RoleAssistant = 'assistant'",
              "Message format templates for Human/Assistant prefixes"
            ]
          },
          "testable_properties": [],
          "function_id": "ClaudeRunner.RunClaudeConversation",
          "related_concepts": [
            "ConversationMessage struct",
            "role-based formatting",
            "conversation history",
            "strings.Builder",
            "prompt assembly"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_009.4",
          "description": "Implement real-time streaming output using goroutines for concurrent stdout/stderr processing with proper synchronization",
          "type": "sub_process",
          "parent_id": "REQ_009",
          "children": [],
          "acceptance_criteria": [
            "Stdout streaming goroutine reads line-by-line using bufio.Scanner",
            "Each stdout line is immediately printed to console using fmt.Println for real-time display",
            "Output is accumulated in strings.Builder for final ClaudeResult.Output",
            "Stderr goroutine captures error output separately",
            "sync.WaitGroup tracks goroutine completion with Add(1) before each and Done() at end",
            "Main thread calls wg.Wait() after cmd.Wait() to ensure all output is captured",
            "os.Stdout.Sync() called after wg.Wait() to flush output buffer",
            "Debug logging shows line count progress every 10 lines for long-running operations",
            "Goroutines handle scanner errors gracefully without panicking",
            "Stdin write goroutine closes pipe after writing to signal EOF to Claude"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create sync.WaitGroup variable for goroutine synchronization",
              "Call wg.Add(1) before launching stdout streaming goroutine",
              "Launch stdout goroutine with defer wg.Done() at start",
              "Create bufio.Scanner(stdout) for line-by-line reading",
              "Loop with scanner.Scan() to read each line",
              "Call fmt.Println(line) for immediate console output",
              "Append line + newline to strings.Builder for accumulation",
              "Track lineCount and log every 10 lines for progress visibility",
              "Call wg.Add(1) before launching stderr capture goroutine",
              "Launch stderr goroutine with defer wg.Done() at start",
              "Create bufio.Scanner(stderr) and accumulate to stderrBuilder",
              "Launch stdin write goroutine with defer stdin.Close()",
              "Write prompt bytes to stdin pipe",
              "Call cmd.Wait() to wait for process completion",
              "Call wg.Wait() to ensure goroutines finish processing buffered data",
              "Call os.Stdout.Sync() to flush any remaining output"
            ],
            "middleware": [],
            "shared": [
              "Debug log format strings for goroutine status",
              "Line count threshold constant for progress logging (10 lines)"
            ]
          },
          "testable_properties": [],
          "function_id": "ClaudeRunner.StreamingWithGoroutines",
          "related_concepts": [
            "goroutines",
            "sync.WaitGroup",
            "bufio.Scanner",
            "concurrent I/O",
            "channel-based communication",
            "pipe handling"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_009.5",
          "description": "Implement utility functions for Claude CLI availability checking and version retrieval",
          "type": "sub_process",
          "parent_id": "REQ_009",
          "children": [],
          "acceptance_criteria": [
            "ClaudeAvailable() returns bool indicating if claude binary is in PATH",
            "Uses exec.LookPath('claude') to check binary availability",
            "Returns true if LookPath succeeds, false otherwise",
            "GetClaudeVersion() returns version string and error",
            "Executes 'claude --version' command",
            "Captures and returns trimmed output string",
            "Returns wrapped error if command fails",
            "Both functions are safe to call without side effects"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement ClaudeAvailable() bool function",
              "Call exec.LookPath('claude') to find binary",
              "Return err == nil as availability indicator",
              "Implement GetClaudeVersion() (string, error) function",
              "Create exec.Command('claude', '--version')",
              "Call cmd.Output() to capture stdout",
              "Handle error by returning wrapped error with fmt.Errorf",
              "Return strings.TrimSpace(string(output)) on success"
            ],
            "middleware": [],
            "shared": [
              "Claude binary name constant: 'claude'",
              "Version command flag: '--version'"
            ]
          },
          "testable_properties": [],
          "function_id": "ClaudeRunner.UtilityFunctions",
          "related_concepts": [
            "exec.LookPath",
            "exec.Command",
            "CLI integration",
            "version parsing",
            "strings.TrimSpace"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_010",
      "description": "The Implementation Phase must build implementation prompts with TDD plan paths, Epic ID, and Issue IDs",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_010.1",
          "description": "Include TDD plan file path in the implementation prompt to enable Claude to read and implement the detailed plan",
          "type": "sub_process",
          "parent_id": "REQ_010",
          "children": [],
          "acceptance_criteria": [
            "Implementation prompt includes absolute path to TDD plan overview file",
            "Path is validated to exist before inclusion in prompt",
            "Path format is compatible with Claude file reading (e.g., 'Read the plan at: /path/to/plan.md')",
            "Non-absolute paths are resolved relative to project root",
            "Error handling returns PhaseResult with FAILED status if plan file not found",
            "Plan path is registered as a ContextEntry in CentralContextStore with EntryType.PLAN",
            "Plan content is indexed in VectorSearchIndex for future reference",
            "WorkingLLMContext receives summary of plan for orchestrator coordination"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create buildImplementationPrompt(planPath Path, epicID string, issueIDs []string) string function",
              "Implement path validation using filepath.IsAbs() and os.Stat()",
              "Build prompt header with 'Implement the TDD plan at: {planPath}' directive",
              "Add instruction for Claude to read plan overview first, then find phase documents"
            ],
            "middleware": [
              "Implement CWAIntegration.RegisterPlanEntry(planPath string) to store plan as ContextEntry",
              "Configure entry with searchable=true and appropriate priority"
            ],
            "shared": [
              "Define PlanPathConfig struct with ProjectPath, PlanPath, and IsAbsolute fields",
              "Add constant PLAN_READ_INSTRUCTION = 'Read the plan overview first, then find and implement the phase documents'"
            ]
          },
          "testable_properties": [],
          "function_id": "PromptBuilder.includeTDDPlanPath",
          "related_concepts": [
            "TDD plan overview",
            "phase document references",
            "file path resolution",
            "prompt construction",
            "CWA entry registration"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_010.2",
          "description": "Include Beads Epic ID in prompt with show command to enable Claude to view and track the overall epic progress",
          "type": "sub_process",
          "parent_id": "REQ_010",
          "children": [],
          "acceptance_criteria": [
            "Epic ID is included in prompt under '## Beads Tracking' section",
            "Format includes 'Epic: {epicID}' label",
            "Include 'bd show {epicID}' command example for viewing epic details",
            "Epic section is conditionally rendered only when epicID is non-empty",
            "Epic information is registered in CentralContextStore with EntryType.TRACKING",
            "Summary includes epic purpose for WorkingLLMContext visibility"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add epic section to buildImplementationPrompt when epicID != ''",
              "Format: '**Epic**: `{epicID}`' with backticks for monospace rendering",
              "Include 'View: `bd show {epicID}`' command reference",
              "Integrate with bd CLI for epic status verification before prompt generation"
            ],
            "middleware": [
              "Create CWAIntegration.RegisterBeadsEpic(epicID string, title string) method",
              "Store epic as ContextEntry with source='beads' and appropriate references"
            ],
            "shared": [
              "Define BeadsTrackingInfo struct with EpicID, IssueIDs, and Status fields",
              "Add constant BD_SHOW_TEMPLATE = 'bd show %s'"
            ]
          },
          "testable_properties": [],
          "function_id": "PromptBuilder.includeBeadsEpicID",
          "related_concepts": [
            "beads epic tracking",
            "bd show command",
            "epic status visibility",
            "progress tracking",
            "CWA beads entry"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_010.3",
          "description": "Include all Phase Issue IDs in prompt to enable Claude to track and update individual phase progress through beads",
          "type": "sub_process",
          "parent_id": "REQ_010",
          "children": [],
          "acceptance_criteria": [
            "All phase issue IDs are listed under '**Phase Issues**:' section",
            "Each issue is formatted as '- Phase {N}: `{issueID}`' with phase number and issue ID",
            "Phase numbers start at 1 and increment sequentially",
            "Issue IDs preserve ordering from beads integration step",
            "Empty issue_ids list results in section being omitted",
            "Each phase issue is registered in CentralContextStore with parent_id linking to epic",
            "TaskBatcher can batch phases based on CWA entry limits"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add '**Phase Issues**:' section header when issueIDs slice is non-empty",
              "Iterate over issueIDs with index starting at 1 for human-readable phase numbers",
              "Format each line as '- Phase {i+1}: `{issueID}`'",
              "Append newline after issue list for visual separation"
            ],
            "middleware": [
              "Implement CWAIntegration.RegisterPhaseIssues(issues []PhaseIssue, epicID string) method",
              "Set parent_id to epic entry ID for hierarchical tracking",
              "Calculate phase dependencies based on issue ordering"
            ],
            "shared": [
              "Reuse PhaseIssue struct from steps.go with Phase, File, and IssueID fields",
              "Define PHASE_ISSUE_FORMAT = '- Phase %d: `%s`'"
            ]
          },
          "testable_properties": [],
          "function_id": "PromptBuilder.includePhaseIssueIDs",
          "related_concepts": [
            "phase tracking",
            "beads issues",
            "dependency ordering",
            "phase-to-issue mapping",
            "CWA phase entries"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_010.4",
          "description": "Include implementation instructions for Red-Green-Refactor TDD cycle to guide Claude through proper test-driven development",
          "type": "sub_process",
          "parent_id": "REQ_010",
          "children": [],
          "acceptance_criteria": [
            "Instructions section includes numbered steps (1-7) for TDD workflow",
            "Step 1: Read the plan overview at the specified path",
            "Step 2: Find the phase documents in the same directory",
            "Step 3: Implement the highest priority TASK using subagents",
            "Step 4: Run all tests with 'pytest' or 'make test' commands",
            "Step 5: Update the plan with progress",
            "Step 6: Use 'bd close <id>' when phase is complete",
            "Step 7: Use '/clear' after closing an issue to start fresh",
            "CRITICAL section emphasizes /clear after ALL TESTS PASS and after each successful bd close",
            "Instructions are stored in CWA as reusable context entry with high priority"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add '## Implementation Instructions' section header",
              "Include 7 numbered steps with clear, actionable directives",
              "Add '**CRITICAL**:' callout for /clear command requirement",
              "Specify test commands: 'pytest' primary, 'make test' fallback"
            ],
            "middleware": [
              "Create CWAIntegration.RegisterInstructionContext(instructions string) method",
              "Store with high priority (9) for visibility in WorkingLLMContext",
              "Mark as non-compressible since instructions must remain complete"
            ],
            "shared": [
              "Define TDDInstructions constant with full instruction text",
              "Add TestCommands struct with Primary ('pytest -v') and Fallback ('make test') fields"
            ]
          },
          "testable_properties": [],
          "function_id": "PromptBuilder.includeRedGreenRefactorInstructions",
          "related_concepts": [
            "TDD methodology",
            "red-green-refactor",
            "test-first development",
            "pytest execution",
            "subagent coordination",
            "CWA instruction context"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_010.5",
          "description": "Include instructions for closing beads issues to enable proper progress tracking and phase transition",
          "type": "sub_process",
          "parent_id": "REQ_010",
          "children": [],
          "acceptance_criteria": [
            "Prompt includes 'Use `bd` commands to track progress' section header",
            "Include 'bd ready' command to see available work",
            "Include 'bd show <id>' command to view issue details",
            "Include 'bd update <id> --status=in_progress' command to start work",
            "Include 'bd close <id>' command to complete work with note about dependency unblocking",
            "Include 'bd sync' command to sync changes",
            "Commands are formatted as code blocks for easy copying",
            "Workflow state transitions are tracked in CentralContextStore"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add '## Beads Tracking' section before phase issues",
              "Format bd commands using triple-backtick code block with 'bash' language hint",
              "Include inline comments explaining each command's purpose",
              "Add '(unblocks next)' note to bd close command to explain dependency cascade"
            ],
            "middleware": [
              "Implement CWAIntegration.TrackWorkflowTransition(issueID string, fromStatus string, toStatus string)",
              "Register command executions as ContextEntry with EntryType.COMMAND_RESULT",
              "Enable search by status to find in-progress or completed phases"
            ],
            "shared": [
              "Define BeadsCommands struct with Ready, Show, Update, Close, Sync string templates",
              "Add WorkflowStatus enum with Pending, InProgress, Closed values",
              "Define BD_COMMANDS_TEMPLATE constant with full code block"
            ]
          },
          "testable_properties": [],
          "function_id": "PromptBuilder.includeBeadsCloseInstructions",
          "related_concepts": [
            "beads workflow",
            "issue lifecycle",
            "status transitions",
            "bd close command",
            "dependency unblocking",
            "CWA workflow tracking"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_011",
      "description": "The Implementation Phase must verify all beads issues are closed before marking complete",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_011.1",
          "description": "Execute bd show command for each issue ID to retrieve current issue status from beads tracking system",
          "type": "sub_process",
          "parent_id": "REQ_011",
          "children": [],
          "acceptance_criteria": [
            "Function accepts a single issue ID string parameter",
            "Function executes 'bd show <issue_id>' command via subprocess",
            "Command executes in the correct project working directory",
            "Command has a 30-second timeout to prevent hanging",
            "Function captures both stdout and stderr from command execution",
            "Function returns CommandResult struct with success status, output, and error fields",
            "Function handles missing or invalid issue IDs gracefully without crashing",
            "Function logs the command being executed for debugging purposes"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Use existing BeadsRunner.Show() method from go/internal/exec/beads.go:70-72",
              "Pass context.Context with timeout for cancellation support",
              "Return *CommandResult with Stdout containing issue details"
            ],
            "middleware": [
              "Validate issue ID is non-empty string before execution",
              "Apply DefaultBeadsTimeout (30 seconds) from beads.go:10"
            ],
            "shared": [
              "CommandResult struct from go/internal/exec package",
              "BeadsRunner struct with configured working directory"
            ]
          },
          "testable_properties": [],
          "function_id": "BeadsRunner.ShowIssueStatus",
          "related_concepts": [
            "beads CLI",
            "issue tracking",
            "subprocess execution",
            "command timeout",
            "working directory context"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_011.2",
          "description": "Parse bd show command output to determine if issue status is closed or done",
          "type": "sub_process",
          "parent_id": "REQ_011",
          "children": [],
          "acceptance_criteria": [
            "Function accepts raw command output string as parameter",
            "Function converts output to lowercase for case-insensitive matching",
            "Function checks for 'status: closed' pattern in output",
            "Function checks for 'status: done' pattern in output",
            "Function returns true if either closed or done status is found",
            "Function returns false if neither status pattern is found",
            "Function handles empty output string returning false",
            "Function handles malformed output without panicking",
            "Function trims whitespace from output before parsing"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create parseIssueStatus(output string) bool function",
              "Use strings.ToLower() for case-insensitive comparison",
              "Use strings.Contains() to check for 'status: closed' and 'status: done'",
              "Return boolean indicating closed status"
            ],
            "middleware": [],
            "shared": [
              "Define STATUS_CLOSED = 'status: closed' constant",
              "Define STATUS_DONE = 'status: done' constant"
            ]
          },
          "testable_properties": [],
          "function_id": "IssueStatusChecker.ParseStatusFromOutput",
          "related_concepts": [
            "string parsing",
            "case-insensitive matching",
            "status patterns",
            "output normalization"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_011.3",
          "description": "Iterate through all issue IDs and return false immediately if any issue is not closed",
          "type": "sub_process",
          "parent_id": "REQ_011",
          "children": [],
          "acceptance_criteria": [
            "Function accepts project path string and slice of issue ID strings",
            "Function returns true immediately if issue ID slice is empty",
            "Function iterates through each issue ID in order",
            "Function calls bd show for each issue ID",
            "Function parses status from each command output",
            "Function returns false immediately upon finding first non-closed issue (fail-fast)",
            "Function returns true only if ALL issues have closed or done status",
            "Function handles command execution errors by returning false",
            "Function logs which issue ID caused the false return for debugging",
            "Function has configurable timeout per issue check (default 30s)"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create checkAllIssuesClosed(projectPath string, issueIDs []string) bool function in go/internal/planning/implementation.go",
              "Create BeadsRunner instance with WithBeadsWorkingDir(projectPath)",
              "Use context.Background() with timeout for each Show() call",
              "Loop through issueIDs slice with range",
              "Call parseIssueStatus() on each Show() result",
              "Return false immediately if any parseIssueStatus returns false",
              "Return true after successful iteration through all issues"
            ],
            "middleware": [
              "Validate projectPath exists and is a directory",
              "Validate issueIDs slice is not nil (empty is valid)"
            ],
            "shared": [
              "BeadsRunner from go/internal/exec/beads.go",
              "Context timeout constants for issue checking"
            ]
          },
          "testable_properties": [],
          "function_id": "IssueStatusChecker.CheckAllIssuesClosed",
          "related_concepts": [
            "early termination",
            "iteration",
            "fail-fast pattern",
            "bulk status check"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_011.4",
          "description": "Continue the implementation loop if any beads issues remain open, allowing Claude to continue working",
          "type": "sub_process",
          "parent_id": "REQ_011",
          "children": [],
          "acceptance_criteria": [
            "Loop checks issue status after each Claude invocation",
            "Loop sleeps for configured interval (10 seconds) before status check",
            "Loop continues to next iteration if checkAllIssuesClosed returns false",
            "Loop only proceeds to test verification when all issues are closed",
            "Loop respects maximum iteration limit (default 100)",
            "Loop logs current iteration count and open issue status",
            "Loop tracks which issues remain open for progress reporting",
            "Loop emits clear progress messages: 'Issues still open, continuing...'",
            "Loop increments iteration counter after each full cycle",
            "Loop exits with error if max iterations reached with issues still open"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add loop continuation logic in StepImplementation() in go/internal/planning/implementation.go",
              "Call time.Sleep(IMPL_LOOP_SLEEP) before status check",
              "Call checkAllIssuesClosed(projectPath, beadsIssueIDs)",
              "If returns false: log status, continue to next loop iteration",
              "If returns true: proceed to runTests() verification",
              "Track iteration count in ImplementationResult.Iterations",
              "Set IMPL_MAX_ITERATIONS = 100 constant",
              "Set IMPL_LOOP_SLEEP = 10 * time.Second constant"
            ],
            "middleware": [
              "Log each iteration with fmt.Printf for visibility",
              "Include sleep duration in configuration for testing"
            ],
            "shared": [
              "ImplementationResult struct with Iterations field",
              "Configuration constants for loop timing"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationLoop.ContinueIfIssuesOpen",
          "related_concepts": [
            "autonomous loop",
            "iteration control",
            "sleep interval",
            "max iterations",
            "loop continuation"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_012",
      "description": "The Implementation Phase must run tests using pytest with fallback to make test",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_012.1",
          "description": "Execute pytest as the primary test command with verbose output and short traceback format",
          "type": "sub_process",
          "parent_id": "REQ_012",
          "children": [],
          "acceptance_criteria": [
            "MUST execute 'pytest -v --tb=short' command in the project directory",
            "MUST set working directory to projectPath before execution",
            "MUST capture both stdout and stderr output streams",
            "MUST use a configurable timeout (default 300 seconds / 5 minutes)",
            "MUST return exit code 0 as success, non-zero as failure",
            "MUST handle subprocess.TimeoutExpired exception gracefully",
            "MUST return tuple of (passed: bool, output: string) with combined stdout+stderr",
            "MUST propagate FileNotFoundError when pytest binary is not found to trigger fallback",
            "MUST NOT modify or interfere with test environment variables"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create runPytest() function in go/internal/planning/implementation.go",
              "Use exec.Command('pytest', '-v', '--tb=short') for subprocess creation",
              "Set cmd.Dir = projectPath for correct working directory",
              "Create context.WithTimeout for enforcing timeout limit",
              "Use cmd.CombinedOutput() to capture both stdout and stderr",
              "Check cmd.ProcessState.ExitCode() for pass/fail determination",
              "Return (true, output) on exit code 0, (false, output) otherwise"
            ],
            "middleware": [],
            "shared": [
              "Define TestTimeout constant = 300 * time.Second (5 minutes)",
              "Define TestResult struct with Passed bool, Output string, Command string, Duration time.Duration",
              "Add error types: ErrTestTimeout, ErrPytestNotFound for specific error handling"
            ]
          },
          "testable_properties": [],
          "function_id": "TestRunner.runPytestPrimary",
          "related_concepts": [
            "subprocess execution",
            "pytest CLI",
            "timeout handling",
            "exit code interpretation",
            "working directory management"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_012.2",
          "description": "Execute 'make test' as fallback when pytest command is not available or fails to start",
          "type": "sub_process",
          "parent_id": "REQ_012",
          "children": [],
          "acceptance_criteria": [
            "MUST only be invoked when pytest execution fails with FileNotFoundError or exec.ErrNotFound",
            "MUST NOT be invoked when pytest runs but tests fail (exit code non-zero)",
            "MUST execute 'make test' command in the project directory",
            "MUST set working directory to projectPath before execution",
            "MUST capture both stdout and stderr output streams",
            "MUST use same timeout as pytest (300 seconds default)",
            "MUST return exit code 0 as success, non-zero as failure",
            "MUST handle case where Makefile or 'test' target doesn't exist gracefully",
            "MUST return (true, 'No test command found, skipping') if neither pytest nor make test available"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create runMakeTest() function in go/internal/planning/implementation.go",
              "Use exec.Command('make', 'test') for subprocess creation",
              "Set cmd.Dir = projectPath for correct working directory",
              "Create context.WithTimeout for enforcing timeout limit",
              "Use cmd.CombinedOutput() to capture both stdout and stderr",
              "Handle exec.ErrNotFound to detect missing make command",
              "Check for 'No rule to make target' in stderr to detect missing test target"
            ],
            "middleware": [],
            "shared": [
              "Reuse TestTimeout constant from pytest implementation",
              "Reuse TestResult struct for consistent return type"
            ]
          },
          "testable_properties": [],
          "function_id": "TestRunner.runMakeTestFallback",
          "related_concepts": [
            "Makefile targets",
            "fallback pattern",
            "subprocess execution",
            "error recovery",
            "build system integration"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_012.3",
          "description": "Orchestrate test execution with pytest-first strategy and automatic make test fallback",
          "type": "sub_process",
          "parent_id": "REQ_012",
          "children": [],
          "acceptance_criteria": [
            "MUST attempt pytest -v --tb=short first before any fallback",
            "MUST fallback to make test ONLY when pytest binary is not found (FileNotFoundError/exec.ErrNotFound)",
            "MUST NOT fallback when pytest runs but tests fail (tests failing is a valid result, not an error)",
            "MUST return (passed: bool, output: string) tuple matching Python implementation signature",
            "MUST combine all output from whichever command runs for debugging purposes",
            "MUST log which test command was used for transparency",
            "MUST handle timeout errors from either command consistently",
            "MUST return (true, 'No test command found, skipping') only if both pytest and make are unavailable"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create runTests(projectPath string) (bool, string) function in go/internal/planning/implementation.go",
              "Call runPytest() first, check for exec.ErrNotFound or os.ErrNotExist",
              "If pytest not found, call runMakeTest() as fallback",
              "If make test also not found, return (true, 'No test command found, skipping')",
              "Log test command selection: fmt.Printf('Running tests with: %s\\n', command)",
              "Return actual test result (passed, output) from whichever command executed"
            ],
            "middleware": [],
            "shared": [
              "Consider integrating with existing go/internal/exec/buildtools.go BuildToolRunner",
              "Align with BuildToolRunner.RunTests() method signature for consistency",
              "Consider using BuildToolRunner.DetectTestCommand() for project-type-aware detection"
            ]
          },
          "testable_properties": [],
          "function_id": "TestRunner.runTests",
          "related_concepts": [
            "fallback chain",
            "error handling",
            "test orchestration",
            "result aggregation",
            "command detection"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_012.4",
          "description": "Continue the implementation loop when tests fail, allowing Claude to fix issues in subsequent iterations",
          "type": "sub_process",
          "parent_id": "REQ_012",
          "children": [],
          "acceptance_criteria": [
            "MUST continue loop iteration when tests fail (tests_passed = false)",
            "MUST NOT exit loop or mark implementation as complete when tests fail",
            "MUST log test failure output for debugging: fmt.Printf('Tests failed, continuing loop:\\n%s\\n', output)",
            "MUST include test failure output in next Claude prompt context if applicable",
            "MUST track consecutive test failures to detect non-convergent implementations",
            "MUST respect max_iterations limit even when tests consistently fail",
            "MUST clear previous test failure errors when tests eventually pass: errors.clear() equivalent",
            "MUST only break loop when BOTH all beads issues are closed AND tests pass"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "In StepImplementation loop, call runTests() after checkAllIssuesClosed() returns true",
              "Store test result: passed, output := runTests(projectPath)",
              "If !passed: log output, append to errors slice, continue to next iteration",
              "If passed: clear errors slice (errors = []string{}), break loop",
              "Add consecutiveFailures counter for debugging/monitoring",
              "Log iteration status: fmt.Printf('Iteration %d: issues_closed=%v, tests_passed=%v\\n', i, allClosed, passed)"
            ],
            "middleware": [],
            "shared": [
              "Define ImplementationResult struct with TestsPassed bool field",
              "Add Iterations int field to track loop count",
              "Add TestOutput string field for last test run output",
              "Add ConsecutiveTestFailures int for convergence monitoring"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationLoop.handleTestFailure",
          "related_concepts": [
            "TDD red-green-refactor",
            "autonomous loop",
            "error recovery",
            "iteration management",
            "convergence detection"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_013",
      "description": "The Checkpoint Manager must support write, detect, and cleanup operations",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_013.1",
          "description": "Write checkpoint file with state, phase name, and error messages to enable pipeline resume functionality",
          "type": "sub_process",
          "parent_id": "REQ_013",
          "children": [],
          "acceptance_criteria": [
            "Creates `.rlm-act-checkpoints/` directory if it does not exist with 0755 permissions",
            "Generates a unique UUID v4 for each checkpoint file name",
            "Serializes checkpoint data to JSON with 2-space indentation",
            "Checkpoint JSON contains: id, phase, timestamp (RFC3339), state, errors array, git_commit",
            "Writes file atomically to prevent corruption on interruption",
            "Returns absolute path to created checkpoint file on success",
            "Returns error if directory creation fails",
            "Returns error if JSON marshaling fails",
            "Returns error if file write fails",
            "Timestamp is in ISO 8601 format with UTC timezone indicator (Z suffix)",
            "State parameter must be convertible to map[string]interface{} via ToCheckpointDict()",
            "Errors parameter accepts nil/empty slice and stores as empty array"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define Checkpoint struct with ID, Phase, Timestamp, State, Errors, GitCommit fields and JSON tags",
              "Implement NewCheckpointManager(projectPath string) constructor",
              "Implement WriteCheckpoint(state map[string]interface{}, phase string, errors []string) (string, error)",
              "Use github.com/google/uuid package for UUID generation",
              "Use encoding/json for marshaling with MarshalIndent",
              "Use os.MkdirAll for directory creation",
              "Use os.WriteFile for atomic file write with 0644 permissions"
            ],
            "middleware": [],
            "shared": [
              "Define const CheckpointsDir = \".rlm-act-checkpoints\"",
              "Define Checkpoint struct in models.go or manager.go",
              "Add ToCheckpointDict() method to PipelineState/PipelineResults struct"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.WriteCheckpoint",
          "related_concepts": [
            "UUID generation",
            "JSON serialization",
            "PipelineState",
            "file system operations",
            "atomic writes",
            "checkpoint directory management"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_013.2",
          "description": "Detect and return the most recent checkpoint file for pipeline resume operations",
          "type": "sub_process",
          "parent_id": "REQ_013",
          "children": [],
          "acceptance_criteria": [
            "Returns nil if checkpoints directory does not exist",
            "Returns nil if checkpoints directory is empty",
            "Scans all *.json files in checkpoints directory",
            "Parses each JSON file and extracts timestamp field",
            "Sorts checkpoints by timestamp in descending order (newest first)",
            "Returns the checkpoint with most recent timestamp",
            "Adds file_path field to returned checkpoint data containing absolute path",
            "Gracefully skips files with JSON parse errors without failing",
            "Gracefully skips files with IO read errors without failing",
            "Returns error only for unexpected failures (not missing/empty directory)",
            "Checkpoint validation includes checking required fields: id, phase, timestamp, state"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement DetectResumableCheckpoint() (*Checkpoint, error) method",
              "Use filepath.Glob to find *.json files in checkpoints directory",
              "Use os.ReadFile and json.Unmarshal for each file",
              "Use sort.Slice to sort by timestamp string (RFC3339 is lexicographically sortable)",
              "Return first element after sorting (newest)",
              "Add FilePath string field to Checkpoint struct for tracking source"
            ],
            "middleware": [],
            "shared": [
              "Add FilePath field to Checkpoint struct",
              "Consider helper function ParseTimestamp(string) (time.Time, error) for timestamp handling"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.DetectResumableCheckpoint",
          "related_concepts": [
            "file system scanning",
            "JSON deserialization",
            "timestamp sorting",
            "checkpoint validation",
            "error handling for corrupt files"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_013.3",
          "description": "Delete checkpoint files older than specified number of days to manage disk space",
          "type": "sub_process",
          "parent_id": "REQ_013",
          "children": [],
          "acceptance_criteria": [
            "Returns (0, 0) if checkpoints directory does not exist",
            "Accepts days parameter as positive integer",
            "Calculates cutoff time as current time minus days parameter",
            "Parses timestamp from each checkpoint JSON file",
            "Deletes files where checkpoint timestamp is before cutoff time",
            "Returns tuple of (deleted_count, failed_count)",
            "Increments deleted_count for each successfully removed file",
            "Increments failed_count for each file that could not be removed",
            "Does not count JSON parse failures as failed deletions (skips silently)",
            "Handles timezone-aware timestamps (Z suffix and +00:00 format)",
            "Age calculation uses days (24-hour periods), not calendar days"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement CleanupByAge(days int) (int, int) method",
              "Use time.Now().AddDate(0, 0, -days) to calculate cutoff time",
              "Implement GetCheckpointAgeDays(checkpoint *Checkpoint) int helper",
              "Parse ISO 8601 timestamps handling both Z and +00:00 timezone formats",
              "Use os.Remove for file deletion",
              "Track deleted and failed counts separately"
            ],
            "middleware": [],
            "shared": [
              "Helper function to parse ISO 8601 timestamp strings to time.Time",
              "Consider adding DeleteCheckpoint(path string) bool helper method"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.CleanupByAge",
          "related_concepts": [
            "file age calculation",
            "timestamp parsing",
            "bulk file deletion",
            "cleanup statistics",
            "ISO 8601 duration"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_013.4",
          "description": "Delete all checkpoint files to reset pipeline state completely",
          "type": "sub_process",
          "parent_id": "REQ_013",
          "children": [],
          "acceptance_criteria": [
            "Returns (0, 0) if checkpoints directory does not exist",
            "Scans all *.json files in checkpoints directory",
            "Attempts to delete each file found",
            "Returns tuple of (deleted_count, failed_count)",
            "Increments deleted_count for each successfully removed file",
            "Increments failed_count for each file that could not be removed (permission errors, etc.)",
            "Does not delete the checkpoints directory itself, only contents",
            "Does not delete non-JSON files in the directory",
            "Continues processing remaining files if one deletion fails"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement CleanupAll() (int, int) method",
              "Use filepath.Glob(filepath.Join(checkpointsDir, \"*.json\")) to find files",
              "Use os.Remove for each file deletion",
              "Track success and failure counts in loop"
            ],
            "middleware": [],
            "shared": []
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.CleanupAll",
          "related_concepts": [
            "bulk file deletion",
            "directory cleanup",
            "file system permissions",
            "cleanup statistics"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_013.5",
          "description": "Retrieve and store current git commit SHA in checkpoint for version tracking and reproducibility",
          "type": "sub_process",
          "parent_id": "REQ_013",
          "children": [],
          "acceptance_criteria": [
            "Executes `git rev-parse HEAD` in project directory",
            "Returns 40-character SHA-1 commit hash on success",
            "Returns empty string if not in a git repository",
            "Returns empty string if git command fails (git not installed, etc.)",
            "Returns empty string if working directory is invalid",
            "Trims whitespace from command output",
            "Does not propagate errors to caller (graceful degradation)",
            "Uses project path as working directory for git command",
            "Timeout on git command to prevent hanging (recommend 5 seconds)"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Implement getGitCommit(projectPath string) string private method",
              "Use os/exec.Command to run git rev-parse HEAD",
              "Set cmd.Dir to projectPath",
              "Use cmd.Output() to capture stdout",
              "Use strings.TrimSpace on output",
              "Return empty string on any error (exec.Error, non-zero exit, etc.)",
              "Consider context.WithTimeout for command timeout"
            ],
            "middleware": [],
            "shared": [
              "This is called internally by WriteCheckpoint, not exposed as public API",
              "Consider caching git commit during pipeline run to avoid repeated subprocess calls"
            ]
          },
          "testable_properties": [],
          "function_id": "CheckpointManager.StoreGitCommit",
          "related_concepts": [
            "git integration",
            "subprocess execution",
            "version control",
            "commit hash",
            "repository state"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_014",
      "description": "The Pipeline Orchestrator must integrate all 8 steps including the new Implementation phase",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_014.1",
          "description": "Execute existing pipeline steps 1-7 (Research, Memory Sync, Requirement Decomposition, Context Generation, Planning, Phase Decomposition, Beads Integration)",
          "type": "sub_process",
          "parent_id": "REQ_014",
          "children": [],
          "acceptance_criteria": [
            "All 7 existing steps execute in sequence: Research \u2192 Memory Sync \u2192 Requirement Decomposition \u2192 Context Generation \u2192 Planning \u2192 Phase Decomposition \u2192 Beads Integration",
            "Each step result is stored in results.Steps map with appropriate key names",
            "Pipeline returns early with results.Success=false and results.FailedAt set if any critical step fails",
            "Non-critical steps (memory_sync, context_generation) continue on failure without blocking pipeline",
            "Step execution timing is captured in results.Started and results.Completed",
            "Pipeline correctly passes outputs between steps (research.ResearchPath \u2192 decomposition, planning.PlanPath \u2192 phase_decomposition, etc.)",
            "BeadsIntegrationResult contains EpicID and PhaseIssues array for handoff to implementation phase"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Maintain existing Run() method in go/internal/planning/pipeline.go",
              "Ensure StepResearch() returns ResearchPath for downstream steps",
              "Ensure StepPlanning() returns PlanPath for phase decomposition",
              "Ensure StepPhaseDecomposition() returns PhaseFiles array",
              "Ensure StepBeadsIntegration() returns EpicID and PhaseIssues for implementation",
              "Add validation that required outputs exist before proceeding to dependent steps"
            ],
            "middleware": [
              "Add logging/tracing for step transitions",
              "Implement timeout handling per step using context.WithTimeout"
            ],
            "shared": [
              "Use existing StepResult struct for step outputs",
              "Use existing BeadsIntegrationResult struct for beads outputs",
              "Use existing PipelineResults struct for aggregated results"
            ]
          },
          "testable_properties": [],
          "function_id": "PlanningPipeline.Run",
          "related_concepts": [
            "pipeline orchestration",
            "step execution",
            "error handling",
            "result aggregation",
            "sequential workflow"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_014.2",
          "description": "Add Step 8: Implementation Phase - autonomous TDD loop that invokes Claude, checks beads issue status, and runs tests until complete",
          "type": "sub_process",
          "parent_id": "REQ_014",
          "children": [],
          "acceptance_criteria": [
            "New StepImplementation() function is created in go/internal/planning/implementation.go",
            "Function accepts: projectPath string, phasePaths []string, beadsIssueIDs []string, beadsEpicID string, maxIterations int",
            "Loop iterates up to maxIterations (default 100) times",
            "Each iteration: (1) invokes Claude with implementation prompt, (2) sleeps IMPL_LOOP_SLEEP (10s), (3) checks if all beads issues are closed",
            "When all issues closed: runs tests using runTests(), breaks loop if tests pass, continues if tests fail",
            "Returns ImplementationResult struct with Success, Error, Iterations, TestsPassed, PhasesClosed fields",
            "Implementation prompt includes TDD plan path, beads epic ID, phase issue IDs, and implementation instructions",
            "Claude invocation uses RunClaudeSync() with IMPL_TIMEOUT (3600s) and streaming enabled"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create go/internal/planning/implementation.go with StepImplementation() function",
              "Implement buildImplementationPrompt() to construct Claude prompt with plan path, epic ID, and issue IDs",
              "Implement checkAllIssuesClosed() using 'bd show <id>' command to verify status contains 'status: closed' or 'status: done'",
              "Implement runTests() that tries 'pytest -v --tb=short' first, falls back to 'make test'",
              "Add constants: IMPL_LOOP_SLEEP=10s, IMPL_MAX_ITERATIONS=100, IMPL_TIMEOUT=3600"
            ],
            "middleware": [
              "Handle Claude invocation failures gracefully (log and continue loop)",
              "Handle test command not found gracefully (skip tests if neither pytest nor make test available)"
            ],
            "shared": [
              "Create ImplementationResult struct with Success, Error, Iterations, TestsPassed, PhasesClosed fields",
              "Reuse existing RunClaudeSync() from claude_runner.go"
            ]
          },
          "testable_properties": [],
          "function_id": "PlanningPipeline.StepImplementation",
          "related_concepts": [
            "autonomous loop",
            "TDD implementation",
            "beads issue tracking",
            "test execution",
            "Claude invocation",
            "implementation phase"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_014.3",
          "description": "Call StepImplementation with project path, phase paths, issue IDs, epic ID, max iterations and integrate into main pipeline flow",
          "type": "sub_process",
          "parent_id": "REQ_014",
          "children": [],
          "acceptance_criteria": [
            "Pipeline Run() method updated to include Step 8 after Step 7 (Beads Integration)",
            "Step 8 header printed: 'STEP 8/8: IMPLEMENTATION PHASE'",
            "Phase paths extracted from decomposition.PhaseFiles",
            "Issue IDs extracted from beads.PhaseIssues array using helper function getIssueIDsFromBeads()",
            "Epic ID extracted from beads.EpicID",
            "MaxIterations taken from pipeline config or defaults to IMPL_MAX_ITERATIONS",
            "StepImplementation() called with all extracted parameters"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Update Run() method in go/internal/planning/pipeline.go to add Step 8 section",
              "Add helper function getIssueIDsFromBeads(beads *BeadsIntegrationResult) []string",
              "Add MaxIterations field to PipelineConfig struct",
              "Pass decomposition.PhaseFiles as phasePaths parameter",
              "Call StepImplementation() after beads integration step"
            ],
            "middleware": [],
            "shared": [
              "Update PipelineConfig struct to include MaxIterations int field"
            ]
          },
          "testable_properties": [],
          "function_id": "PlanningPipeline.IntegrateImplementation",
          "related_concepts": [
            "pipeline integration",
            "step chaining",
            "parameter extraction",
            "step invocation"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_014.4",
          "description": "Store implementation result in results.Steps map with proper success/failure handling",
          "type": "sub_process",
          "parent_id": "REQ_014",
          "children": [],
          "acceptance_criteria": [
            "Implementation result stored in results.Steps['implementation']",
            "If implementation fails (impl.Success=false), pipeline sets results.Success=false",
            "If implementation fails, results.FailedAt set to 'implementation'",
            "If implementation fails, results.Error set to impl.Error message",
            "On failure, pipeline returns immediately with current results",
            "On success, pipeline continues to completion logic"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add results.Steps['implementation'] = impl assignment in Run() method",
              "Add failure check: if !impl.Success { results.Success = false; results.FailedAt = 'implementation'; results.Error = impl.Error; return results }",
              "Store ImplementationResult directly in Steps map (interface{} type)"
            ],
            "middleware": [],
            "shared": [
              "ImplementationResult struct must be JSON-serializable for storage in Steps map"
            ]
          },
          "testable_properties": [],
          "function_id": "PipelineResults.StoreImplementation",
          "related_concepts": [
            "result storage",
            "error propagation",
            "step result mapping"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_014.5",
          "description": "Handle implementation failure with proper error reporting including iteration count, test output, and phase status",
          "type": "sub_process",
          "parent_id": "REQ_014",
          "children": [],
          "acceptance_criteria": [
            "On max iterations reached, error message includes iteration count: 'Max iterations (N) reached'",
            "On test failure after issues closed, error includes truncated test output (first 500 chars)",
            "Implementation result includes iterations count for debugging",
            "Implementation result includes TestsPassed boolean flag",
            "Implementation result includes PhasesClosed array showing which phases completed",
            "Pipeline logs clear error message to stdout before returning",
            "Error message includes suggestion to check beads status: 'Run bd ready to see remaining work'"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "ImplementationResult.Error set to descriptive message including iteration count",
              "runTests() returns (bool, string) with test output for error reporting",
              "Track closed phases in PhasesClosed array during loop execution",
              "Add fmt.Printf error logging before returning failed result",
              "Include diagnostic information in ImplementationResult.Error field"
            ],
            "middleware": [
              "Log each iteration number during loop execution",
              "Log test results when tests fail after issues are closed"
            ],
            "shared": [
              "ImplementationResult struct includes all diagnostic fields: Iterations, TestsPassed, PhasesClosed, Error"
            ]
          },
          "testable_properties": [],
          "function_id": "PlanningPipeline.HandleImplementationFailure",
          "related_concepts": [
            "error handling",
            "failure reporting",
            "diagnostic output",
            "pipeline failure"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_014.6",
          "description": "Port Context Window Array integration from Python to Go for managing context entries throughout pipeline phases",
          "type": "sub_process",
          "parent_id": "REQ_014",
          "children": [],
          "acceptance_criteria": [
            "Create go/internal/context/ package with CWA implementation",
            "CentralContextStore implemented with in-memory entry storage and TF-IDF search",
            "ContextEntry struct matches Python: id, entry_type, source, content, summary, ttl fields",
            "EntryType enum includes: FILE, TASK, COMMAND types",
            "WorkingLLMContext builds summaries-only context for orchestrator",
            "ImplementationLLMContext builds full-content context with entry limits",
            "TaskBatcher creates batches respecting max_entries_per_batch limit",
            "Store supports search(), add(), get(), remove(), compress_multiple() operations",
            "TTL management: process_turn() decrements TTL and removes expired entries",
            "Integration with StepImplementation for context-aware prompts"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Create go/internal/context/store.go with CentralContextStore struct and methods",
              "Create go/internal/context/entry.go with ContextEntry struct and EntryType enum",
              "Create go/internal/context/working.go with WorkingLLMContext and WorkingContext structs",
              "Create go/internal/context/implementation.go with ImplementationLLMContext and ImplementationContext structs",
              "Create go/internal/context/search.go with VectorSearchIndex using TF-IDF",
              "Create go/internal/context/batching.go with TaskBatcher, TaskBatch, TaskSpec structs",
              "Implement store_research(), store_requirement(), store_plan(), store_command_result() methods",
              "Implement build_working_context(), build_impl_context() methods",
              "Implement process_turn() for TTL management",
              "Implement compress_entries() for memory optimization"
            ],
            "middleware": [
              "Context bounds validation before building implementation context",
              "Automatic TTL cleanup on each pipeline turn"
            ],
            "shared": [
              "Create go/internal/context/integration.go with CWAIntegration struct",
              "ContextEntry struct with JSON tags for serialization",
              "StoreSearchResult struct for search results with scores",
              "TaskSpec struct for task batching input"
            ]
          },
          "testable_properties": [],
          "function_id": "CWAIntegration.PortToGo",
          "related_concepts": [
            "context management",
            "entry storage",
            "working context",
            "implementation context",
            "TF-IDF search",
            "task batching",
            "TTL management"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_015",
      "description": "The system must implement the specified Go file structure with planning, checkpoints, context, and cli packages",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_015.1",
          "description": "Implements the autonomous loop for the implementation phase, interacting with Claude and checking bead status.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The function correctly constructs Claude prompts based on the TDD plan and bead issue IDs.",
            "The function executes the Claude API with streaming output, capturing the response.",
            "The function sleeps for 10 seconds after each Claude invocation.",
            "The function checks if all bead issues are closed before proceeding to the next iteration.",
            "If all bead issues are closed, the function executes tests (pytest or make test).",
            "If tests pass, the function breaks the loop and marks the phase as complete.",
            "If tests fail, the function continues the loop to fix the tests.",
            "The function returns a PhaseResult with the iteration count."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API Integration",
              "Test Execution (pytest or make test)",
              "Loop Control Logic"
            ],
            "middleware": [
              "Concurrency Management (Goroutines)",
              "Rate Limiting (if necessary)"
            ],
            "shared": [
              "Prompt Template",
              "Test Suite Configuration",
              "PhaseResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "StepImplementationLoop",
          "related_concepts": [
            "Claude API",
            "Bead Status",
            "Test Execution",
            "Concurrency (Goroutines)",
            "Loop Control"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.1.1",
          "description": "Runs Claude with a given file, streaming output and handling potential errors.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The function correctly constructs the Claude prompt with the provided file content.",
            "The function executes the Claude API with streaming output, capturing the response.",
            "The function handles potential errors during the Claude API call (e.g., network errors, API errors).",
            "The function returns the Claude response or an error if the API call fails."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API Integration",
              "Error Handling"
            ],
            "middleware": [],
            "shared": [
              "Prompt Template",
              "Error Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "RunClaudeWithFile",
          "related_concepts": [
            "Claude API",
            "Streaming Output",
            "Error Handling",
            "Concurrency (Goroutines)"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.2",
          "description": "Implement the autonomous loop pattern for the implementation phase, mimicking the Python code's behavior. This includes building the prompt, iterating up to a maximum of 100 times, invoking Claude with the prompt, sleeping for 10 seconds, and checking if all beads issues are closed. If the loop completes without success, return a failure result.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The code correctly constructs the prompt with the TDD plan and beads issue IDs.",
            "The code iterates up to 100 times.",
            "The code successfully invokes Claude with the prompt and captures the streaming output.",
            "The code sleeps for 10 seconds between Claude invocations.",
            "The code accurately checks if all beads issues are closed.",
            "If all beads issues are closed, the code executes tests (pytest or make test).",
            "If tests pass, the code breaks the loop and marks the phase as complete, returning a success result.",
            "If tests fail, the code continues the loop to fix the issues.",
            "The code returns a result object with the iteration count and a success/failure flag."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API integration",
              "Test execution framework integration",
              "Result object creation"
            ],
            "middleware": [],
            "shared": [
              "Prompt template",
              "Beads issue ID retrieval",
              "Test execution command",
              "Result object schema"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Autonomous Loop",
            "Claude API",
            "Beads Integration",
            "Test Execution",
            "Checkpointing"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.3",
          "description": "Implement the autonomous loop pattern for the implementation phase, mimicking the Python code's behavior. This includes building the prompt, iterating up to a maximum of 100 times, invoking Claude with the prompt, sleeping for 10 seconds, and checking if all beads issues are closed. If all are closed, run tests and break the loop. If tests fail, continue the loop.  Handle timeouts gracefully.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The loop executes up to 100 iterations.",
            "Claude is invoked with the generated prompt.",
            "The loop sleeps for 10 seconds between Claude invocations.",
            "The code checks if all beads issues are closed before each Claude invocation.",
            "If all beads issues are closed, the code runs tests (pytest or make test).",
            "If tests pass, the loop breaks and the phase is marked complete.",
            "If tests fail, the loop continues to fix the issue.",
            "The code handles timeouts gracefully (e.g., returns an error if Claude doesn't respond within a reasonable time).",
            "The code correctly tracks the iteration count."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this function."
            ],
            "backend": [
              "Implement the core logic for the loop and Claude invocation.",
              "Handle the Claude API calls.",
              "Implement the logic for checking if all beads issues are closed.",
              "Implement the testing framework (pytest or make test).",
              "Implement the timeout handling."
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Define constants for the loop iterations and sleep time.",
              "Define data structures for the prompt and the Claude output.",
              "Implement a function to run tests."
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Autonomous Loop",
            "Claude API",
            "Testing (pytest or make test)",
            "Beads Integration",
            "Timeouts"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.4",
          "description": "Implement the autonomous loop for the implementation phase, mimicking the Python logic.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The loop iterates a maximum of 100 times.",
            "Each iteration invokes Claude with a prompt generated from the TDD plan and beads issue IDs.",
            "Claude's streaming output is captured and processed.",
            "A 10-second sleep is implemented between Claude calls.",
            "The loop checks if all beads issues are closed after each Claude invocation.",
            "If all issues are closed, the loop breaks, and a phase result is returned.",
            "If tests fail, the loop continues to fix the issue.",
            "The function returns a `StepResult` with the iteration count."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API Integration",
              "Concurrency Management (Goroutines)",
              "Timer Management"
            ],
            "middleware": [
              "Rate Limiting (to prevent Claude API overload)",
              "Error Handling"
            ],
            "shared": [
              "Prompt Template",
              "Beads Issue IDs",
              "Test Execution Framework (pytest or make test)",
              "StepResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_1",
          "related_concepts": [
            "Claude API",
            "Streaming Output",
            "Concurrency (Goroutines)",
            "Iteration Control"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.4.1",
          "description": "Implement the loop sleep functionality.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The sleep duration is configurable (defaulting to 10 seconds).",
            "The sleep duration is implemented using a Goroutine to avoid blocking the main thread.",
            "The sleep duration is accurately measured and controlled."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Timer Management (Goroutine)",
              "Concurrency Management"
            ],
            "middleware": [],
            "shared": [
              "Sleep Duration Configuration"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_2",
          "related_concepts": [
            "Concurrency",
            "Time Management",
            "Goroutines"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.4.2",
          "description": "Implement the loop iteration limit.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The loop iterates a maximum of 100 times.",
            "The loop breaks when the iteration count exceeds 100.",
            "The iteration count is accurately tracked and used to control the loop."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Iteration Counter",
              "Concurrency Management"
            ],
            "middleware": [],
            "shared": [
              "Maximum Iterations Configuration"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_3",
          "related_concepts": [
            "Iteration Control",
            "Concurrency",
            "Maximum Iterations"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.4.3",
          "description": "Implement the loop check for beads issue closure.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "The loop checks if all beads issues are closed after each Claude invocation.",
            "The loop uses the Claude API to check the status of each beads issue.",
            "The loop handles API errors gracefully."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Claude API Integration",
              "Status Checking"
            ],
            "middleware": [
              "Error Handling"
            ],
            "shared": [
              "Beads Issue IDs",
              "Claude API Authentication"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_4",
          "related_concepts": [
            "Beads Issue IDs",
            "API Integration",
            "Status Checking"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.4.4",
          "description": "Implement the loop break and phase result return.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "If all beads issues are closed, the loop breaks and a phase result is returned.",
            "The phase result includes the iteration count.",
            "The phase result is stored in a `StepResult` data structure."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Data Structure Management",
              "Loop Control"
            ],
            "middleware": [],
            "shared": [
              "StepResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_5",
          "related_concepts": [
            "Phase Result",
            "Loop Control",
            "Data Structures"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_015.4.5",
          "description": "Implement the loop continue for test failures.",
          "type": "sub_process",
          "parent_id": "REQ_015",
          "children": [],
          "acceptance_criteria": [
            "If tests fail, the loop continues to fix the issue.",
            "The loop handles test execution errors gracefully.",
            "The loop continues until the tests pass or the maximum iteration count is reached."
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Test Execution Framework",
              "Error Handling",
              "Concurrency Management"
            ],
            "middleware": [],
            "shared": [
              "Test Execution Framework",
              "StepResult Data Structure"
            ]
          },
          "testable_properties": [],
          "function_id": "IMPL_LOOP_6",
          "related_concepts": [
            "Test Execution",
            "Error Handling",
            "Loop Control"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_016",
      "description": "The system must implement constants for Implementation Phase timing and limits",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_016.1",
          "description": "Define the sleep duration constant between implementation loop iterations as 10 seconds using Go time.Duration",
          "type": "sub_process",
          "parent_id": "REQ_016",
          "children": [],
          "acceptance_criteria": [
            "IMPL_LOOP_SLEEP constant is defined as 10 * time.Second in go/internal/planning/implementation.go",
            "Constant is exported (uppercase) for package-level visibility",
            "Constant is of type time.Duration for direct use with time.Sleep()",
            "Value exactly matches Python implementation specification of 10 seconds",
            "Sleep duration does not count against IMPL_TIMEOUT iteration timeout",
            "Sleep can be interrupted via context cancellation for graceful shutdown support",
            "Constant is documented with godoc comment explaining its purpose in the implementation loop"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add IMPL_LOOP_SLEEP constant at package level in implementation.go",
              "Use time.Sleep(IMPL_LOOP_SLEEP) in implementation loop after RunClaudeSync() call and before checkAllIssuesClosed()",
              "Consider using select with time.After(IMPL_LOOP_SLEEP) and context.Done() channel for cancellation support",
              "Ensure sleep is silent (no output during wait period)"
            ],
            "middleware": [],
            "shared": [
              "Import time package in implementation.go",
              "Define: const IMPL_LOOP_SLEEP = 10 * time.Second",
              "Add godoc: // IMPL_LOOP_SLEEP is the delay between implementation loop iterations to allow Claude and external systems to process"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationConstants.IMPL_LOOP_SLEEP",
          "related_concepts": [
            "time.Duration",
            "time.Sleep",
            "loop pacing",
            "rate limiting",
            "context cancellation"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_016.2",
          "description": "Define the maximum number of implementation loop iterations constant as 100 to prevent infinite loops",
          "type": "sub_process",
          "parent_id": "REQ_016",
          "children": [],
          "acceptance_criteria": [
            "IMPL_MAX_ITERATIONS constant is defined as integer value 100 in go/internal/planning/implementation.go",
            "Constant is exported (uppercase) for package-level visibility",
            "Constant matches Python implementation specification of 100 maximum iterations",
            "StepImplementation() uses this as default when maxIterations parameter is 0 or unspecified",
            "maxIterations function parameter can override this default when non-zero",
            "Loop terminates with error message when max iterations reached without success",
            "ImplementationResult.Iterations tracks actual iteration count for reporting",
            "Error message includes max iteration count: 'Max iterations (100) reached'"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add IMPL_MAX_ITERATIONS constant at package level in implementation.go",
              "StepImplementation() checks if maxIterations == 0 and sets it to IMPL_MAX_ITERATIONS as default",
              "Main loop uses for i := 0; i < maxIterations; i++ pattern",
              "Track result.Iterations = i + 1 inside loop for accurate count",
              "On loop exhaustion: set result.Success = false and result.Error = fmt.Sprintf('Max iterations (%d) reached', maxIterations)"
            ],
            "middleware": [],
            "shared": [
              "Define: const IMPL_MAX_ITERATIONS = 100",
              "Add godoc: // IMPL_MAX_ITERATIONS is the default maximum iterations for the implementation loop before declaring failure",
              "ImplementationResult struct must include Iterations int field with json:\"iterations\" tag"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationConstants.IMPL_MAX_ITERATIONS",
          "related_concepts": [
            "loop termination",
            "safety bounds",
            "iteration counter",
            "configurable defaults",
            "ImplementationResult.Iterations"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_016.3",
          "description": "Define the per-iteration Claude invocation timeout constant as 3600 seconds (1 hour) for long-running implementation tasks",
          "type": "sub_process",
          "parent_id": "REQ_016",
          "children": [],
          "acceptance_criteria": [
            "IMPL_TIMEOUT constant is defined as integer value 3600 in go/internal/planning/implementation.go",
            "Constant represents seconds (matching RunClaudeSync timeoutSecs parameter type)",
            "Constant is exported (uppercase) for package-level visibility",
            "Value exactly matches Python implementation specification of 3600 seconds (1 hour)",
            "This timeout applies per Claude invocation, not to the entire implementation phase",
            "Timeout is passed to RunClaudeSync(prompt, IMPL_TIMEOUT, true, projectPath) in implementation loop",
            "Claude timeout errors (context.DeadlineExceeded) do not terminate loop - loop continues to retry",
            "Timeout is independent of IMPL_LOOP_SLEEP (sleep does not count against timeout)"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add IMPL_TIMEOUT constant at package level in implementation.go",
              "Call RunClaudeSync(prompt, IMPL_TIMEOUT, true, projectPath) in implementation loop",
              "Log iteration number and Claude exit status to stderr on each iteration",
              "On Claude timeout/failure: log warning but continue loop (may be transient network/API issue)",
              "Do not set result.Success = false on individual Claude failures - only on max iterations"
            ],
            "middleware": [],
            "shared": [
              "Define: const IMPL_TIMEOUT = 3600 // 1 hour per iteration",
              "Add godoc: // IMPL_TIMEOUT is the maximum time in seconds for each Claude invocation during implementation",
              "Reuse existing ClaudeResult struct from claude_runner.go for capturing invocation results"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationConstants.IMPL_TIMEOUT",
          "related_concepts": [
            "context.WithTimeout",
            "exec.CommandContext",
            "ClaudeResult",
            "RunClaudeSync timeout parameter",
            "graceful timeout handling"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_017",
      "description": "The PipelineConfig must be extended to support AutonomyMode and MaxIterations",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_017.1",
          "description": "Add AutonomyMode field to PipelineConfig struct to support three autonomy modes (checkpoint, batch, fully_autonomous) instead of the current binary AutoApprove flag",
          "type": "sub_process",
          "parent_id": "REQ_017",
          "children": [],
          "acceptance_criteria": [
            "AutonomyMode type is defined as an integer enum with three values: AutonomyCheckpoint (0), AutonomyBatch (1), AutonomyFull (2)",
            "AutonomyMode has a String() method returning 'checkpoint', 'batch', or 'fully_autonomous'",
            "PipelineConfig struct includes AutonomyMode field of type AutonomyMode",
            "Default value of AutonomyMode is AutonomyCheckpoint (pause after each phase)",
            "AutonomyCheckpoint mode pauses pipeline after each phase for user review",
            "AutonomyBatch mode pauses pipeline between phase groups (research+decomposition, planning+phase_decomposition, beads+implementation)",
            "AutonomyFull mode runs all phases without pauses",
            "Existing AutoApprove bool field is preserved for backward compatibility but deprecated",
            "Pipeline Run() method respects AutonomyMode for determining when to pause",
            "Unit tests verify all three autonomy modes behave correctly"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define AutonomyMode type as 'type AutonomyMode int' in models.go",
              "Add const block with AutonomyCheckpoint, AutonomyBatch, AutonomyFull iota values",
              "Implement String() method on AutonomyMode for serialization/logging",
              "Add AutonomyMode field to PipelineConfig struct in pipeline.go",
              "Update Run() method to check AutonomyMode before each phase transition",
              "Add phase grouping logic for BATCH mode (group 1: research+memory+decomposition, group 2: context+planning+phase_decomposition, group 3: beads+implementation)",
              "Implement pauseForUserApproval() helper function that respects AutonomyMode",
              "Add JSON tags for AutonomyMode serialization in checkpoint files"
            ],
            "middleware": [],
            "shared": [
              "Add ValidAutonomyModes map for validation: {'checkpoint': true, 'batch': true, 'fully_autonomous': true}",
              "Add ParseAutonomyMode(string) (AutonomyMode, error) function for CLI parsing",
              "Update checkpoint state serialization to include AutonomyMode"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PipelineConfig.AddAutonomyModeField",
          "related_concepts": [
            "AutonomyMode enum",
            "pipeline orchestration",
            "phase grouping",
            "user interaction modes",
            "Python parity"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_017.2",
          "description": "Add MaxIterations field to PipelineConfig struct to control the maximum number of implementation loop iterations before timeout",
          "type": "sub_process",
          "parent_id": "REQ_017",
          "children": [],
          "acceptance_criteria": [
            "PipelineConfig struct includes MaxIterations field of type int",
            "Default value of MaxIterations is 100 (matching Python IMPL_MAX_ITERATIONS constant)",
            "MaxIterations value of 0 is treated as 'use default' (100 iterations)",
            "MaxIterations is passed to StepImplementation() function when implementation phase is invoked",
            "Implementation loop terminates after MaxIterations if all beads issues are not closed",
            "ImplementationResult includes actual iteration count when loop completes",
            "CLI accepts --max-iterations flag to override default value",
            "Validation ensures MaxIterations is non-negative (negative values return error)",
            "MaxIterations is persisted in checkpoint state for resume capability",
            "Unit tests verify iteration limit is respected and loop terminates correctly"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add MaxIterations int field to PipelineConfig struct in pipeline.go",
              "Define IMPL_MAX_ITERATIONS constant (100) in implementation.go for default value",
              "Update StepImplementation() signature to accept maxIterations parameter",
              "Implement iteration counting in implementation loop (for i := 0; i < maxIterations; i++)",
              "Return error with iteration count when max iterations reached without completion",
              "Add MaxIterations to ImplementationResult struct for reporting actual iterations used"
            ],
            "middleware": [],
            "shared": [
              "Add MaxIterations validation in PipelineConfig.Validate() method (must be >= 0)",
              "Update checkpoint state structure to include MaxIterations",
              "Add JSON tag 'max_iterations' for serialization"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PipelineConfig.AddMaxIterationsField",
          "related_concepts": [
            "implementation phase",
            "autonomous loop",
            "iteration limits",
            "safety bounds",
            "TDD cycle control"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_017.3",
          "description": "Ensure existing ProjectPath, AutoApprove, and TicketID fields remain functional and backward compatible while integrating new fields",
          "type": "sub_process",
          "parent_id": "REQ_017",
          "children": [],
          "acceptance_criteria": [
            "ProjectPath string field remains unchanged and required",
            "AutoApprove bool field is preserved with deprecation notice in godoc comment",
            "TicketID string field remains unchanged and optional",
            "AutoApprove=true maps to AutonomyMode=AutonomyFull when AutonomyMode is not explicitly set",
            "AutoApprove=false maps to AutonomyMode=AutonomyCheckpoint when AutonomyMode is not explicitly set",
            "Explicit AutonomyMode setting takes precedence over AutoApprove",
            "All existing callers of NewPlanningPipeline() continue to work without modification",
            "CLI --auto-approve flag continues to work but sets AutonomyMode=AutonomyFull",
            "Warning log emitted when AutoApprove is used instead of AutonomyMode",
            "Existing test cases pass without modification"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add '// Deprecated: Use AutonomyMode instead' comment to AutoApprove field",
              "Implement resolveAutonomyMode() method that returns effective AutonomyMode based on both fields",
              "Update NewPlanningPipeline() to call resolveAutonomyMode() for backward compatibility",
              "Add log.Warn() when AutoApprove is true but AutonomyMode is default (showing deprecation)",
              "Ensure Run() method uses resolved AutonomyMode, not raw field values",
              "Add integration test verifying AutoApprove=true behavior matches AutonomyFull"
            ],
            "middleware": [],
            "shared": [
              "Update PipelineConfig JSON serialization to include all fields",
              "Add migration helper MigrateLegacyConfig(oldConfig) -> newConfig for checkpoint files",
              "Document deprecation timeline in package-level godoc"
            ]
          },
          "testable_properties": [],
          "function_id": "planning.PipelineConfig.MaintainExistingFields",
          "related_concepts": [
            "backward compatibility",
            "field preservation",
            "migration path",
            "deprecation strategy",
            "existing behavior"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_018",
      "description": "The Checkpoint struct must include all required fields for state persistence",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_018.1",
          "description": "UUID identifier field for unique checkpoint identification across sessions",
          "type": "sub_process",
          "parent_id": "REQ_018",
          "children": [],
          "acceptance_criteria": [
            "ID field is defined as string type in Checkpoint struct",
            "ID uses UUID v4 format (xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx)",
            "ID is generated using github.com/google/uuid package",
            "ID is set during WriteCheckpoint() before file creation",
            "ID is used as the filename base (ID + .json)",
            "ID is included in JSON serialization with json:\"id\" tag",
            "ID cannot be empty when writing checkpoint",
            "ID validation rejects non-UUID formatted strings on load"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define ID field in Checkpoint struct with string type",
              "Import github.com/google/uuid package",
              "Generate UUID using uuid.New().String() in WriteCheckpoint()",
              "Use ID as checkpoint filename: filepath.Join(checkpointsDir, checkpoint.ID+\".json\")",
              "Validate ID format when loading checkpoint from file"
            ],
            "middleware": [],
            "shared": [
              "Checkpoint struct definition in go/internal/checkpoints/manager.go",
              "JSON struct tag: ID string `json:\"id\"`",
              "UUID validation helper function: IsValidUUID(string) bool"
            ]
          },
          "testable_properties": [],
          "function_id": "Checkpoint.ID",
          "related_concepts": [
            "UUID v4 generation",
            "checkpoint file naming",
            "checkpoint lookup",
            "state persistence"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_018.2",
          "description": "Phase field storing current pipeline phase name for resume targeting",
          "type": "sub_process",
          "parent_id": "REQ_018",
          "children": [],
          "acceptance_criteria": [
            "Phase field is defined as string type in Checkpoint struct",
            "Phase follows naming convention: {phase-name}-{status} (e.g., research-complete, decomposition-failed)",
            "Phase is included in JSON serialization with json:\"phase\" tag",
            "Phase cannot be empty when writing checkpoint",
            "Phase value matches one of the valid pipeline phases: research, decomposition, planning, phase_decomposition, beads_integration, implementation",
            "Phase status suffix is either 'complete' or 'failed'",
            "DetectResumableCheckpoint() uses Phase to determine resume point",
            "Phase is displayed in checkpoint status output"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define Phase field in Checkpoint struct with string type",
              "Create ValidPhases map for validation: research, decomposition, planning, phase_decomposition, beads_integration, implementation",
              "Create ValidPhaseStatuses: complete, failed",
              "Implement ParsePhase(phase string) (phaseName string, status string, error) helper",
              "Validate Phase format in WriteCheckpoint() before file creation",
              "Use Phase in DetectResumableCheckpoint() to determine which step to resume from"
            ],
            "middleware": [],
            "shared": [
              "Checkpoint struct definition with Phase field",
              "JSON struct tag: Phase string `json:\"phase\"`",
              "PhaseType constants or enum for valid phase names",
              "PhaseStatus constants for complete/failed"
            ]
          },
          "testable_properties": [],
          "function_id": "Checkpoint.Phase",
          "related_concepts": [
            "pipeline phases",
            "resume functionality",
            "phase transitions",
            "checkpoint naming conventions"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_018.3",
          "description": "Timestamp field in RFC3339 format for checkpoint ordering and age calculation",
          "type": "sub_process",
          "parent_id": "REQ_018",
          "children": [],
          "acceptance_criteria": [
            "Timestamp field is defined as string type in Checkpoint struct",
            "Timestamp is formatted using time.RFC3339 (e.g., 2006-01-02T15:04:05Z07:00)",
            "Timestamp is included in JSON serialization with json:\"timestamp\" tag",
            "Timestamp is set to current time using time.Now().Format(time.RFC3339) during WriteCheckpoint()",
            "Timestamp cannot be empty when writing checkpoint",
            "DetectResumableCheckpoint() sorts checkpoints by Timestamp descending (newest first)",
            "CleanupByAge() parses Timestamp to calculate age in days",
            "Timestamp parsing handles both Z suffix and timezone offset formats",
            "GetCheckpointAgeDays() returns correct age calculation from Timestamp"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define Timestamp field in Checkpoint struct with string type",
              "Set Timestamp using time.Now().Format(time.RFC3339) in WriteCheckpoint()",
              "Implement ParseTimestamp(ts string) (time.Time, error) helper for flexible parsing",
              "Implement GetCheckpointAgeDays(checkpoint *Checkpoint) int for age calculation",
              "Sort checkpoints by Timestamp in DetectResumableCheckpoint() using sort.Slice",
              "Handle timezone normalization when comparing timestamps across different zones"
            ],
            "middleware": [],
            "shared": [
              "Checkpoint struct definition with Timestamp field",
              "JSON struct tag: Timestamp string `json:\"timestamp\"`",
              "Time parsing utilities that handle RFC3339 with/without Z suffix"
            ]
          },
          "testable_properties": [],
          "function_id": "Checkpoint.Timestamp",
          "related_concepts": [
            "RFC3339 format",
            "time.Time",
            "checkpoint ordering",
            "age-based cleanup",
            "timezone handling"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_018.4",
          "description": "State field as map[string]interface{} for storing arbitrary pipeline state data",
          "type": "sub_process",
          "parent_id": "REQ_018",
          "children": [],
          "acceptance_criteria": [
            "State field is defined as map[string]interface{} type in Checkpoint struct",
            "State is included in JSON serialization with json:\"state\" tag",
            "State stores complete pipeline state including: research_output, decomposition_result, planning_output, phase_files, beads_data",
            "State is populated from PipelineResults.ToCheckpointMap() or equivalent method",
            "State can be restored using FromCheckpointMap(state map[string]interface{}) method",
            "State handles nested structures (maps, slices) during JSON round-trip",
            "State preserves all keys and values after JSON marshal/unmarshal cycle",
            "Empty State map is allowed but logged as warning",
            "State field omits nil values using omitempty for cleaner JSON output"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define State field in Checkpoint struct with map[string]interface{} type",
              "Implement ToCheckpointMap() method on PipelineResults to convert state",
              "Implement FromCheckpointMap(map[string]interface{}) (*PipelineResults, error) for restoration",
              "Handle type assertions safely when extracting typed data from State map",
              "Implement GetString(key string) string helper for safe string extraction",
              "Implement GetStringSlice(key string) []string helper for safe slice extraction",
              "Log warning if State is empty during WriteCheckpoint()"
            ],
            "middleware": [],
            "shared": [
              "Checkpoint struct definition with State field",
              "JSON struct tag: State map[string]interface{} `json:\"state\"`",
              "State key constants for standard fields: StateKeyResearchOutput, StateKeyDecompositionResult, etc.",
              "Type-safe getter methods for common state data types"
            ]
          },
          "testable_properties": [],
          "function_id": "Checkpoint.State",
          "related_concepts": [
            "state serialization",
            "pipeline state",
            "JSON marshaling",
            "state restoration",
            "PipelineState conversion"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_018.5",
          "description": "Errors field as string slice for tracking pipeline errors and failure reasons",
          "type": "sub_process",
          "parent_id": "REQ_018",
          "children": [],
          "acceptance_criteria": [
            "Errors field is defined as []string type in Checkpoint struct",
            "Errors is included in JSON serialization with json:\"errors,omitempty\" tag",
            "Errors contains human-readable error messages from failed pipeline steps",
            "Errors is populated when WriteCheckpoint() is called with errors parameter",
            "Errors can be nil/empty for successful checkpoints",
            "Each error message is a complete description (not just error codes)",
            "Errors are preserved in order of occurrence",
            "DetectResumableCheckpoint() exposes Errors for user decision on resume",
            "Errors are displayed in checkpoint status output for debugging"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Define Errors field in Checkpoint struct with []string type",
              "Accept errors []string parameter in WriteCheckpoint() method",
              "Initialize Errors to empty slice (not nil) if no errors provided: errors or []string{}",
              "Append errors chronologically as they occur during pipeline execution",
              "Implement AddError(msg string) method for incremental error collection",
              "Display errors when showing checkpoint status to user",
              "Include error count in checkpoint summary output"
            ],
            "middleware": [],
            "shared": [
              "Checkpoint struct definition with Errors field",
              "JSON struct tag: Errors []string `json:\"errors,omitempty\"`",
              "Error formatting helpers for consistent message format",
              "HasErrors() bool method for quick error state check"
            ]
          },
          "testable_properties": [],
          "function_id": "Checkpoint.Errors",
          "related_concepts": [
            "error tracking",
            "failure diagnostics",
            "error aggregation",
            "checkpoint recovery",
            "debugging support"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_019",
      "description": "The system must add new CLI commands for status and cleanup operations",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_019.1",
          "description": "Implement the autonomous loop pattern for the implementation phase, mimicking the Python code's behavior. This includes building the prompt, iterating up to a maximum of 100 times, invoking Claude with the prompt, sleeping for 10 seconds, and checking if all beads issues are closed. If so, run tests and break the loop. If tests fail, continue the loop.  Handle potential errors and timeouts gracefully.",
          "type": "sub_process",
          "parent_id": "REQ_019",
          "children": [],
          "acceptance_criteria": [
            "The code correctly builds the prompt with the TDD plan and beads issue IDs.",
            "The loop iterates up to 100 times.",
            "Claude is invoked with the prompt and streaming output is captured.",
            "The code sleeps for 10 seconds.",
            "The code checks if all beads issues are closed.",
            "If all issues are closed, tests are run (pytest or make test).",
            "If tests pass, the loop breaks and the phase is marked complete.",
            "If tests fail, the loop continues to fix the issues.",
            "The code handles potential errors and timeouts gracefully.",
            "The function returns a PhaseResult with the iteration count."
          ],
          "implementation": {
            "frontend": [
              "No UI components are required for this function."
            ],
            "backend": [
              "Invoke Claude API (using streaming)",
              "Execute tests (pytest or make test)",
              "Handle API responses and errors",
              "Manage concurrency (goroutines)"
            ],
            "middleware": [
              "Error handling middleware",
              "Logging middleware"
            ],
            "shared": [
              "Data models (PhaseResult, StepResult)",
              "Configuration constants",
              "Utility functions"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationLoop",
          "related_concepts": [
            "Claude API",
            "Beads Integration",
            "Test Execution (pytest)",
            "Concurrency (goroutines)",
            "Error Handling",
            "Timeouts"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_019.2",
          "description": "Implement the autonomous loop pattern for the implementation phase, mimicking the Python code's behavior. This involves building the prompt, iterating up to a maximum of 100 times, invoking Claude with the prompt, sleeping for 10 seconds, and checking if all beads issues are closed before proceeding to the next iteration.  If tests fail, the loop continues.  Finally, return a PhaseResult with the iteration count.",
          "type": "sub_process",
          "parent_id": "REQ_019",
          "children": [],
          "acceptance_criteria": [
            "The code correctly constructs the prompt with the TDD plan and beads issue IDs.",
            "The code iterates up to 100 times.",
            "The code invokes Claude with the prompt and streams the output.",
            "The code sleeps for 10 seconds between Claude invocations.",
            "The code checks if all beads issues are closed before proceeding to the next iteration.",
            "If tests fail, the code continues the loop to fix the tests.",
            "If tests pass, the code breaks the loop and marks the phase as complete.",
            "The code returns a PhaseResult with the iteration count.",
            "The code handles potential errors during Claude invocation and test execution."
          ],
          "implementation": {
            "frontend": [
              "No UI components are required for this phase."
            ],
            "backend": [
              "A Go function `RunClaudeWithFile()` to interact with the Claude API.",
              "A function `RunClaudeWithFile()` to handle the prompt and Claude interaction.",
              "A function to execute tests (pytest or make test) using the `go test` command.",
              "A function to check if all beads issues are closed (implementation dependent)."
            ],
            "middleware": [
              "No middleware is required for this phase."
            ],
            "shared": [
              "Data models for `PhaseResult` and `StepResult`.",
              "Constants for sleep duration (10 seconds)."
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationPhaseLoop",
          "related_concepts": [
            "Claude API",
            "Beads Integration",
            "Test Execution",
            "PhaseResult",
            "Iteration Count"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_019.3",
          "description": "Implement the autonomous loop pattern for the implementation phase, mimicking the Python version. This includes building the prompt, iterating up to a maximum of 100 times, invoking Claude with the prompt, sleeping for 10 seconds, and checking if all beads issues are closed. If not, the loop continues.  If all issues are closed, tests are run, and if they pass, the loop breaks. If tests fail, the loop continues. Finally, the phase result is returned.",
          "type": "sub_process",
          "parent_id": "REQ_019",
          "children": [],
          "acceptance_criteria": [
            "The code correctly implements the autonomous loop pattern.",
            "The code correctly invokes Claude with the generated prompt.",
            "The code correctly sleeps for 10 seconds.",
            "The code correctly checks if all beads issues are closed.",
            "The code correctly runs tests (pytest or make test) when all issues are closed.",
            "The code correctly handles test failures by continuing the loop.",
            "The code returns a PhaseResult with the iteration count."
          ],
          "implementation": {
            "frontend": [
              "No frontend components are required for this phase."
            ],
            "backend": [
              "A Go function `RunClaudeWithFile()` to handle Claude API calls.",
              "A function `RunClaudeWithFile()` to manage the loop and Claude interaction.",
              "A function to execute tests (pytest or make test) based on test results.",
              "A function to manage the loop iteration count."
            ],
            "middleware": [
              "None"
            ],
            "shared": [
              "Data structures for storing prompt and Claude output.",
              "Constants for loop iteration count and sleep duration."
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementImplementationPhaseLoop",
          "related_concepts": [
            "Claude API",
            "Beads Integration",
            "Test Execution",
            "Autonomous Loop",
            "Streaming Output"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_020",
      "description": "The ImplementationResult struct must track all implementation execution metrics",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_020.1",
          "description": "Define Success boolean field to track whether the implementation phase completed successfully, indicating all beads issues closed and tests passed",
          "type": "sub_process",
          "parent_id": "REQ_020",
          "children": [],
          "acceptance_criteria": [
            "Success bool field exists in ImplementationResult struct with JSON tag `json:\"success\"`",
            "Success is initialized to true at the start of StepImplementation function",
            "Success is set to false when max iterations are reached without completion",
            "Success is set to false when runTests returns false on final iteration",
            "Success remains true only when all beads issues are closed AND tests pass",
            "Success field is serializable to JSON for checkpoint persistence",
            "Success field integrates with PipelineResults.Success for overall pipeline status"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add Success bool field to ImplementationResult struct in go/internal/planning/implementation.go",
              "Initialize result := &ImplementationResult{Success: true} at function start",
              "Set result.Success = false before returning when max iterations exceeded",
              "Set result.Success = false when tests fail after all issues closed",
              "Integrate with StepImplementation return logic to propagate success/failure",
              "Add Success check in pipeline.go Run() method to set PipelineResults.FailedAt"
            ],
            "middleware": [],
            "shared": [
              "Define ImplementationResult struct in implementation.go with proper JSON tags",
              "Ensure struct follows Go naming conventions and JSON serialization patterns matching existing models.go patterns"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.SuccessField",
          "related_concepts": [
            "implementation_phase",
            "pipeline_result",
            "loop_termination",
            "tdd_completion"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_020.2",
          "description": "Define Error string field to capture failure messages when implementation phase fails, including max iterations exceeded, test failures, or Claude invocation errors",
          "type": "sub_process",
          "parent_id": "REQ_020",
          "children": [],
          "acceptance_criteria": [
            "Error string field exists in ImplementationResult struct with JSON tag `json:\"error,omitempty\"`",
            "Error is empty string when Success is true",
            "Error contains 'Max iterations (N) reached' message when loop exhausts iterations",
            "Error contains test failure details when tests fail on final verification",
            "Error contains Claude invocation error if all iterations fail due to Claude errors",
            "Error message is human-readable and actionable for debugging",
            "Error field preserves context about which iteration failed and why",
            "Error field is included in JSON output for checkpoint persistence"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add Error string field to ImplementationResult struct with omitempty JSON tag",
              "Set result.Error = fmt.Sprintf('Max iterations (%d) reached', maxIterations) when loop exhausts",
              "Set result.Error with test output when tests fail: fmt.Sprintf('Tests failed: %s', output)",
              "Capture Claude errors in claudeResult and aggregate for Error field if persistent failures",
              "Include iteration count in error messages for debugging: fmt.Sprintf('Failed at iteration %d: %s', i, err)",
              "Clear Error field when Success transitions to true (should never happen but defensive coding)"
            ],
            "middleware": [],
            "shared": [
              "Follow error message patterns from existing DecompositionError in models.go",
              "Import fmt package for error message formatting",
              "Consider structured error details similar to DecompositionError.Details pattern"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.ErrorField",
          "related_concepts": [
            "error_handling",
            "failure_diagnostics",
            "checkpoint_recovery",
            "pipeline_debugging"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_020.3",
          "description": "Define Iterations integer field to track the number of Claude invocation loops executed during implementation, supporting observability and performance analysis",
          "type": "sub_process",
          "parent_id": "REQ_020",
          "children": [],
          "acceptance_criteria": [
            "Iterations int field exists in ImplementationResult struct with JSON tag `json:\"iterations\"`",
            "Iterations is initialized to 0 at the start of StepImplementation",
            "Iterations increments by 1 at the start of each loop iteration (before Claude invocation)",
            "Iterations contains the final count when loop terminates (success or failure)",
            "Iterations count is preserved in ImplementationResult JSON serialization",
            "Iterations count respects max_iterations limit (default IMPL_MAX_ITERATIONS = 100)",
            "Iteration count is logged/printed at each loop iteration for observability",
            "If loop exits early due to success, Iterations reflects actual iterations run, not max"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add Iterations int field to ImplementationResult struct in implementation.go",
              "Initialize result.Iterations = 0 before entering the for loop",
              "Increment result.Iterations++ at the start of each loop iteration (i.e., result.Iterations = i + 1)",
              "Add fmt.Printf('Implementation iteration %d/%d\\n', result.Iterations, maxIterations) for observability",
              "Ensure Iterations is included in JSON struct tag: `json:\"iterations\"`",
              "Return result with Iterations set regardless of success or failure path"
            ],
            "middleware": [],
            "shared": [
              "Define IMPL_MAX_ITERATIONS constant (100) in implementation.go",
              "Import fmt package for iteration logging"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.IterationsField",
          "related_concepts": [
            "autonomous_loop",
            "claude_invocation",
            "max_iterations",
            "loop_termination",
            "performance_metrics"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_020.4",
          "description": "Define TestsPassed boolean field to track whether the final test suite execution passed after all beads issues are closed, storing boolean status for completion verification",
          "type": "sub_process",
          "parent_id": "REQ_020",
          "children": [],
          "acceptance_criteria": [
            "TestsPassed bool field exists in ImplementationResult struct with JSON tag `json:\"tests_passed\"`",
            "runTests function returns (bool, string) tuple for pass status and output",
            "pytest -v --tb=short is tried first for test execution",
            "make test is used as fallback if pytest command fails or is not found",
            "If neither test command exists, runTests returns (true, 'No test command found, skipping')",
            "Tests are only run after all beads issues are confirmed closed via checkAllIssuesClosed",
            "Test output is captured for debugging when tests fail",
            "TestsPassed field is serialized to JSON with tag `json:\"tests_passed\"`"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add TestsPassed bool field to ImplementationResult struct",
              "Implement runTests(projectPath string) (bool, string) function",
              "Use exec.Command('pytest', '-v', '--tb=short') with cmd.Dir = projectPath",
              "Capture CombinedOutput() for both stdout and stderr",
              "Implement fallback: if pytest fails, try exec.Command('make', 'test')",
              "Set result.TestsPassed = passed after runTests call in the success path",
              "Print test failure output with fmt.Printf('Tests failed, continuing loop:\\n%s\\n', output)",
              "Return early with result when tests pass (Success = true, TestsPassed = true)"
            ],
            "middleware": [],
            "shared": [
              "Import os/exec package for subprocess execution",
              "Import time package for potential timeout handling on test execution",
              "Consider context.WithTimeout for test execution timeouts (300 seconds suggested)"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.TestsPassedField",
          "related_concepts": [
            "pytest",
            "make_test",
            "test_verification",
            "tdd_validation",
            "test_output_capture"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_020.5",
          "description": "Define PhasesClosed string array field to track which beads phase issues have been closed during implementation, storing closed issue IDs for progress monitoring and completion verification",
          "type": "sub_process",
          "parent_id": "REQ_020",
          "children": [],
          "acceptance_criteria": [
            "PhasesClosed []string field exists in ImplementationResult struct with JSON tag `json:\"phases_closed,omitempty\"`",
            "checkAllIssuesClosed function checks each issue ID via bd show command",
            "Issue is considered closed if output contains 'status: closed' or 'status: done' (case insensitive)",
            "checkAllIssuesClosed returns true only when ALL issue IDs are in closed/done status",
            "bd show command has 30 second timeout per issue",
            "If bd command fails or times out, assume issue is not closed (return false)",
            "PhasesClosed is populated with issue IDs as they transition to closed state",
            "PhasesClosed field serializes to JSON with tag `json:\"phases_closed,omitempty\"`"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add PhasesClosed []string field to ImplementationResult struct",
              "Implement checkAllIssuesClosed(projectPath string, issueIDs []string) bool function",
              "Execute bd show <id> for each issue ID using exec.Command",
              "Set cmd.Dir = projectPath for correct working directory context",
              "Convert output to lowercase using strings.ToLower for case-insensitive matching",
              "Check for 'status: closed' or 'status: done' in output using strings.Contains",
              "Implement getClosedIssues helper to return list of currently closed issue IDs",
              "Update result.PhasesClosed = getClosedIssues(projectPath, beadsIssueIDs) after each iteration",
              "Use context.WithTimeout for 30 second timeout on bd show commands"
            ],
            "middleware": [],
            "shared": [
              "Import strings package for ToLower and Contains operations",
              "Import os/exec for bd command execution",
              "Import context and time packages for timeout handling",
              "Follow existing exec.Command patterns from steps.go StepMemorySync"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationResult.PhasesClosedField",
          "related_concepts": [
            "beads_issues",
            "bd_show",
            "bd_close",
            "issue_status",
            "completion_check",
            "progress_tracking"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    },
    {
      "id": "REQ_021",
      "description": "The system must handle errors gracefully in the implementation loop with continuation on transient failures",
      "type": "parent",
      "parent_id": null,
      "children": [
        {
          "id": "REQ_021.1",
          "description": "Continue implementation loop on Claude execution errors, treating Claude failures as transient and allowing the loop to proceed to the next iteration",
          "type": "sub_process",
          "parent_id": "REQ_021",
          "children": [],
          "acceptance_criteria": [
            "Claude execution failures do NOT terminate the implementation loop",
            "Loop continues to next iteration when result.success is false",
            "Failed iterations are counted toward max_iterations limit",
            "No exception propagation from Claude subprocess failures",
            "Error message is logged but does not block loop progress",
            "Python pattern preserved: `if not result['success']: print(error)` then continue",
            "Go RetryPolicy.RetryIf function returns true for Claude execution errors",
            "Transient errors (timeout, network, process killed) trigger continuation",
            "Non-transient permanent failures still allow continuation to next iteration"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "StepImplementation function must wrap Claude invocation in error-tolerant block",
              "Use existing RetryableError function from go/internal/exec/retry.go to classify errors",
              "Check ClaudeResult.Success and continue loop on false",
              "Print failure message to stdout: fmt.Printf(\"Claude iteration %d failed: %s\\n\", i+1, error)",
              "Do not return early from loop on Claude failure",
              "Preserve iteration count increment before Claude invocation"
            ],
            "middleware": [
              "RunClaudeSync must not panic on execution errors",
              "Return ClaudeResult with Success=false and Error populated on failure",
              "Timeout handling should return result, not propagate error"
            ],
            "shared": [
              "ClaudeResult struct must have Success bool and Error string fields",
              "ImplementationResult struct tracks whether any iteration had errors",
              "Error classification constants for transient vs permanent failures"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationPhase.continueOnClaudeError",
          "related_concepts": [
            "transient_failure_handling",
            "retry_policy",
            "fault_tolerance",
            "loop_continuation",
            "subprocess_execution"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_021.2",
          "description": "Log iteration failures with comprehensive error details including iteration number, error message, elapsed time, and context for debugging",
          "type": "sub_process",
          "parent_id": "REQ_021",
          "children": [],
          "acceptance_criteria": [
            "Each failed iteration logs iteration number (1-indexed)",
            "Error message from Claude result is included in log output",
            "Timestamp of failure is recorded",
            "Log format is consistent: 'Claude iteration N failed: <error>'",
            "Log output goes to stdout for terminal visibility",
            "Error details include exit code if available from subprocess",
            "Log includes elapsed time since iteration started",
            "Failed iterations are distinguishable from successful ones in logs",
            "Log severity matches error type (warn for transient, error for permanent)",
            "Structured log fields available for JSON output mode"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Add fmt.Printf statement after Claude invocation failure detection",
              "Include iteration counter in log message: fmt.Printf(\"Claude iteration %d failed: %s\\n\", iteration, result.Error)",
              "Calculate and log elapsed time per iteration using time.Since()",
              "Log test runner output on test failures: fmt.Printf(\"Tests failed, continuing loop:\\n%s\\n\", output)",
              "Add visual separator between iterations: fmt.Println(strings.Repeat(\"=\", 60))",
              "Log loop entry with iteration number for tracking",
              "Consider slog package for structured logging in production"
            ],
            "middleware": [],
            "shared": [
              "Define log format constants for consistent messaging",
              "IterationLog struct with fields: Number int, Success bool, Error string, ElapsedMs int64, Timestamp time.Time",
              "Helper function formatIterationError(iteration int, err string, elapsed time.Duration) string"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationPhase.logIterationFailures",
          "related_concepts": [
            "structured_logging",
            "observability",
            "debugging",
            "error_context",
            "iteration_tracking"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_021.3",
          "description": "Track success/failure status for each iteration in the implementation loop, maintaining a record of all iteration outcomes for reporting and analysis",
          "type": "sub_process",
          "parent_id": "REQ_021",
          "children": [],
          "acceptance_criteria": [
            "ImplementationResult.Iterations field contains total iteration count",
            "Each iteration's success/failure status is recorded",
            "Final result includes count of failed iterations",
            "Final result includes count of successful iterations",
            "Metadata includes iteration history if verbose mode enabled",
            "TestsPassed field indicates final test suite status",
            "PhasesClosed field lists successfully closed beads issues",
            "Duration per iteration is optionally tracked",
            "Result distinguishes between Claude failures and test failures",
            "Iteration that achieved completion is identifiable"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Initialize iteration counter: iteration := 0 before loop",
              "Increment counter at loop start: iteration++",
              "Track Claude success: claudeResult.Success stored per iteration",
              "Track test success after checkAllIssuesClosed: passed, output := runTests()",
              "Set result.Iterations = iteration before return",
              "Set result.TestsPassed = passed after final test run",
              "Collect closed issue IDs in result.PhasesClosed slice",
              "Calculate aggregate success rate: successCount/totalIterations"
            ],
            "middleware": [],
            "shared": [
              "ImplementationResult struct with fields: Success bool, Error string, Iterations int, TestsPassed bool, PhasesClosed []string",
              "Optional IterationRecord struct: {Number int, ClaudeSuccess bool, TestsRun bool, TestsPassed bool, Duration time.Duration}",
              "Metadata map[string]interface{} for additional tracking data"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationPhase.trackIterationStatus",
          "related_concepts": [
            "iteration_tracking",
            "status_aggregation",
            "metrics",
            "phase_result",
            "execution_history"
          ],
          "category": "functional"
        },
        {
          "id": "REQ_021.4",
          "description": "Return comprehensive error result when maximum iterations limit is reached without successful completion, including iteration count and final state details",
          "type": "sub_process",
          "parent_id": "REQ_021",
          "children": [],
          "acceptance_criteria": [
            "Result.Success is false when max_iterations reached",
            "Result.Error contains descriptive message: 'Max iterations (N) reached'",
            "Result.Iterations equals max_iterations value",
            "Result.TestsPassed reflects last test run status",
            "Error message includes max_iterations configuration value",
            "Result includes partial progress information (phases closed so far)",
            "Default max_iterations is 100 if not specified",
            "Loop uses for/else pattern or explicit break detection",
            "Error distinguishes between 'max reached' and other failures",
            "Result can be used for checkpoint resume from last state"
          ],
          "implementation": {
            "frontend": [],
            "backend": [
              "Use for loop with explicit break: for i := 0; i < maxIterations; i++ { ... }",
              "After loop, check if break occurred via success flag or iteration count",
              "Set result.Success = false when loop exhausts without break",
              "Set result.Error = fmt.Sprintf(\"Max iterations (%d) reached\", maxIterations)",
              "Default maxIterations: if maxIterations == 0 { maxIterations = IMPL_MAX_ITERATIONS }",
              "Preserve iteration count in result even on failure: result.Iterations = iteration",
              "Include partial results: result.PhasesClosed = getClosedIssues(issueIDs)",
              "Return result immediately after setting error fields"
            ],
            "middleware": [],
            "shared": [
              "Constant IMPL_MAX_ITERATIONS = 100 for default value",
              "ImplementationResult must support partial success state",
              "Error message format string: \"Max iterations (%d) reached\" for consistency with Python"
            ]
          },
          "testable_properties": [],
          "function_id": "ImplementationPhase.returnMaxIterationsError",
          "related_concepts": [
            "max_iterations_limit",
            "loop_termination",
            "error_reporting",
            "failure_result",
            "safety_bounds"
          ],
          "category": "functional"
        }
      ],
      "acceptance_criteria": [],
      "implementation": null,
      "testable_properties": [],
      "function_id": null,
      "related_concepts": [],
      "category": "functional"
    }
  ],
  "metadata": {
    "source": "agent_sdk_decomposition",
    "research_length": 22523,
    "decomposition_stats": {
      "requirements_found": 22,
      "subprocesses_expanded": 126,
      "total_nodes": 148,
      "extraction_time_ms": 52165,
      "expansion_time_ms": 1911852
    }
  }
}